name: Build Kernel Module with OLLVM

on:
  workflow_dispatch:
    inputs:
      module_dir:
        description: 'Module directory to build'
        required: true
        type: choice
        options:
        - exianb-dev
        - exianb
        - ovo
        - prctl-fd
        - prctl-hook
        - offset
        - hello-world
        - wuwa
        - panic
        default: 'exianb-dev'
      obfuscation_level:
        description: 'OLLVM obfuscation level'
        required: false
        default: 'medium'
        type: choice
        options:
        - none
        - light
        - medium
        - heavy
      use_custom_clang:
        description: 'Use custom OLLVM clang from ZIP'
        required: false
        default: 'false'
        type: boolean
      obfuscation_strategy:
        description: 'Obfuscation strategy when OLLVM fails'
        required: false
        default: 'binary'
        type: choice
        options:
        - try_ollvm_first
        - binary_only
        - symbolic_only
        - hybrid

jobs:
  ddk-build:
    name: Build ${{ inputs.module_dir }}.ko for ${{ matrix.kmi }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        kmi:
          - android12-5.10
          - android13-5.10
          - android13-5.15
          - android14-5.15
          - android14-6.1
          - android15-6.6
          - android16-6.12

    container:
      image: ghcr.io/ylarod/ddk:${{ matrix.kmi }}

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        apt-get update && apt-get install -y \
          unzip \
          file \
          python3 \
          python3-pip \
          xxd \
          upx-ucl
        pip3 install lief

    - name: Extract OLLVM Toolchain
      if: ${{ inputs.use_custom_clang && inputs.obfuscation_strategy != 'binary_only' && inputs.obfuscation_strategy != 'symbolic_only' }}
      run: |
        echo "=== Extracting OLLVM Toolchain ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean any existing ollvm directory
        rm -rf /usr/local/ollvm
        mkdir -p /usr/local/ollvm
        
        # Find and extract ZIP files
        ZIP_COUNT=0
        for zip_file in "$MODULE_DIR"/clang*.zip; do
          if [ -f "$zip_file" ]; then
            ZIP_COUNT=$((ZIP_COUNT + 1))
            echo "=== Extracting $(basename "$zip_file") ==="
            unzip -q "$zip_file" -d /usr/local/ollvm/
          fi
        done
        
        if [ $ZIP_COUNT -eq 0 ]; then
          echo "⚠️ No clang*.zip files found in $MODULE_DIR/"
          echo "Available files:"
          ls -la "$MODULE_DIR"/ || echo "Directory doesn't exist"
          echo "Will use binary obfuscation only"
          echo "OLLVM_AVAILABLE=false" >> $GITHUB_ENV
        else
          # Organize binaries
          echo ""
          echo "=== Organizing Binaries ==="
          
          # Create bin directory
          mkdir -p /usr/local/ollvm/bin
          
          # Move all executables to bin/
          find /usr/local/ollvm -type f -executable -exec mv {} /usr/local/ollvm/bin/ \; 2>/dev/null || true
          
          # Make everything executable
          chmod -R +x /usr/local/ollvm/bin/ 2>/dev/null || true
          
          # Test clang
          echo ""
          echo "=== Testing OLLVM Clang ==="
          if [ -f "/usr/local/ollvm/bin/clang" ]; then
            echo "✅ OLLVM clang found"
            /usr/local/ollvm/bin/clang --version | head -3
            
            # Quick test if OLLVM works
            cat > /tmp/test_ollvm.c << 'EOF'
            int test_func(int x) { return x * 2; }
            EOF
            
            if /usr/local/ollvm/bin/clang -c /tmp/test_ollvm.c -o /tmp/test.o -mllvm -fla 2>&1; then
              echo "✅ OLLVM can compile simple code"
              echo "OLLVM_AVAILABLE=true" >> $GITHUB_ENV
            else
              echo "❌ OLLVM cannot compile even simple code"
              echo "OLLVM_AVAILABLE=false" >> $GITHUB_ENV
            fi
          else
            echo "❌ clang not found in /usr/local/ollvm/bin/"
            echo "OLLVM_AVAILABLE=false" >> $GITHUB_ENV
          fi
          
          # Add to PATH
          export PATH=/usr/local/ollvm/bin:$PATH
          echo 'export PATH=/usr/local/ollvm/bin:$PATH' >> /etc/profile.d/ollvm.sh
        fi

    - name: Build Kernel Module
      run: |
        echo "=== Building ${{ inputs.module_dir }}.ko ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        STRATEGY="${{ inputs.obfuscation_strategy }}"
        USE_OLLVM="${{ inputs.use_custom_clang }}"
        OLLVM_AVAILABLE="${{ env.OLLVM_AVAILABLE || 'false' }}"
        
        # Clean first
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
        
        # Determine build approach based on strategy
        case "$STRATEGY" in
          "try_ollvm_first")
            if [ "$USE_OLLVM" = "true" ] && [ "$OLLVM_AVAILABLE" = "true" ]; then
              echo "=== Strategy: Try OLLVM first ==="
              attempt_ollvm_build "$MODULE_DIR"
            else
              echo "=== Strategy: OLLVM not available, building normally ==="
              build_normal "$MODULE_DIR"
            fi
            ;;
            
          "binary_only")
            echo "=== Strategy: Binary obfuscation only ==="
            build_normal "$MODULE_DIR"
            ;;
            
          "symbolic_only")
            echo "=== Strategy: Symbol obfuscation only ==="
            build_normal "$MODULE_DIR"
            ;;
            
          "hybrid")
            echo "=== Strategy: Hybrid ==="
            build_normal "$MODULE_DIR"
            ;;
            
          *)
            echo "=== Default: Building normally ==="
            build_normal "$MODULE_DIR"
            ;;
        esac
        
        # Check if build was successful
        KO_FILE=$(find "$MODULE_DIR" -name "*.ko" -type f | head -1)
        
        if [ -f "$KO_FILE" ]; then
          echo "✅ Build successful: $KO_FILE"
          cp "$KO_FILE" "$KO_FILE.original"
          echo "ORIGINAL_KO=$KO_FILE.original" >> $GITHUB_ENV
          echo "FINAL_KO=$KO_FILE" >> $GITHUB_ENV
        else
          echo "❌ Build failed: No .ko file found"
          exit 1
        fi

    - name: Apply Obfuscation
      if: ${{ inputs.use_custom_clang && success() }}
      run: |
        echo "=== Applying Obfuscation ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        ORIGINAL_KO="${{ env.ORIGINAL_KO }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        STRATEGY="${{ inputs.obfuscation_strategy }}"
        OBF_LEVEL="${{ inputs.obfuscation_level }}"
        
        if [ ! -f "$ORIGINAL_KO" ] || [ ! -f "$FINAL_KO" ]; then
          echo "❌ Kernel module files not found"
          exit 1
        fi
        
        # Apply obfuscation based on strategy
        case "$STRATEGY" in
          "try_ollvm_first")
            # If OLLVM was used in build, skip additional obfuscation
            if [ "${{ env.OLLVM_USED_IN_BUILD || 'false' }}" = "true" ]; then
              echo "✅ OLLVM was used during compilation, skipping post-processing"
            else
              apply_binary_obfuscation "$FINAL_KO" "$OBF_LEVEL"
            fi
            ;;
            
          "binary_only")
            apply_binary_obfuscation "$FINAL_KO" "$OBF_LEVEL"
            ;;
            
          "symbolic_only")
            apply_symbol_obfuscation "$FINAL_KO" "$OBF_LEVEL"
            ;;
            
          "hybrid")
            apply_binary_obfuscation "$FINAL_KO" "$OBF_LEVEL"
            apply_symbol_obfuscation "$FINAL_KO" "$OBF_LEVEL"
            ;;
            
          *)
            apply_binary_obfuscation "$FINAL_KO" "$OBF_LEVEL"
            ;;
        esac
        
        # Verify the obfuscated module
        verify_module "$FINAL_KO" "$ORIGINAL_KO"

    - name: Create Final Artifact
      run: |
        echo "=== Creating Final Artifact ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        
        if [ ! -f "$FINAL_KO" ]; then
          echo "❌ Final kernel module not found"
          exit 1
        fi
        
        TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
        
        if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
          OBF_LEVEL="${{ inputs.obfuscation_level }}"
          STRATEGY="${{ inputs.obfuscation_strategy }}"
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-$STRATEGY-$OBF_LEVEL-$TIMESTAMP.ko"
        else
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-default-$TIMESTAMP.ko"
        fi
        
        mkdir -p /github/workspace/out
        cp "$FINAL_KO" "/github/workspace/out/$OUTPUT_NAME"
        
        # Strip debug symbols to reduce size
        echo "Stripping debug symbols..."
        llvm-strip -d "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        strip --strip-debug "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        echo "Warning: Could not strip debug symbols"
        
        echo "Final module: $OUTPUT_NAME"
        echo "Size: $(du -h "/github/workspace/out/$OUTPUT_NAME" | cut -f1)"
        echo "ARTIFACT_PATH=/github/workspace/out/$OUTPUT_NAME" >> $GITHUB_ENV

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}
        path: ${{ env.ARTIFACT_PATH }}
        retention-days: 7

    - name: Upload Build Logs
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}-logs
        path: /tmp/build*.log
        retention-days: 7
      if: always()

    # Helper functions (added at the end of the run command)
    - name: Helper Functions Setup
      run: |
        cat > /tmp/helpers.sh << 'EOF'
        #!/bin/bash
        
        # Function to attempt OLLVM build
        attempt_ollvm_build() {
          local MODULE_DIR="$1"
          echo "=== Attempting OLLVM Build ==="
          
          # Set OLLVM flags based on level
          local OLLVM_FLAGS=""
          case "${{ inputs.obfuscation_level }}" in
            "light") OLLVM_FLAGS="-mllvm -fla" ;;
            "medium") OLLVM_FLAGS="-mllvm -fla -mllvm -sub" ;;
            "heavy") OLLVM_FLAGS="-mllvm -fla -mllvm -sub -mllvm -bcf" ;;
            *) OLLVM_FLAGS="" ;;
          esac
          
          # Try multiple approaches
          local ATTEMPTS=(
            # Approach 1: Minimal flags
            "make -C \"\$KERNEL_SRC\" M=\"\$PWD/\$MODULE_DIR\" modules KCFLAGS=\"\$OLLVM_FLAGS -fno-lto -fno-sanitize=cfi\" -j\$(nproc)"
            
            # Approach 2: CC override with minimal flags
            "make -C \"\$KERNEL_SRC\" M=\"\$PWD/\$MODULE_DIR\" modules CC=\"/usr/local/ollvm/bin/clang\" KCFLAGS=\"\$OLLVM_FLAGS -fno-lto -fno-sanitize=cfi\" HOSTCC=\"gcc\" -j\$(nproc)"
            
            # Approach 3: Build individual files
            "build_individual_files \"\$MODULE_DIR\" \"\$OLLVM_FLAGS\""
          )
          
          for i in "${!ATTEMPTS[@]}"; do
            local ATTEMPT_NUM=$((i+1))
            echo ""
            echo "=== OLLVM Attempt $ATTEMPT_NUM ==="
            
            # Clean
            make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
            
            # Run attempt
            set +e
            eval "${ATTEMPTS[$i]}" 2>&1 | tee "/tmp/ollvm_attempt_${ATTEMPT_NUM}.log"
            local RESULT=$?
            set -e
            
            if [ $RESULT -eq 0 ] && [ -f "$MODULE_DIR"/*.ko ]; then
              echo "✅ OLLVM Attempt $ATTEMPT_NUM successful!"
              echo "OLLVM_USED_IN_BUILD=true" >> $GITHUB_ENV
              return 0
            fi
          done
          
          echo "❌ All OLLVM attempts failed, falling back to normal build"
          build_normal "$MODULE_DIR"
          return 1
        }
        
        # Function to build individual files with OLLVM
        build_individual_files() {
          local MODULE_DIR="$1"
          local OLLVM_FLAGS="$2"
          
          echo "Building individual files with OLLVM..."
          
          # Get list of source files
          local SRC_FILES=$(find "$MODULE_DIR/src" -name "*.c" 2>/dev/null)
          if [ -z "$SRC_FILES" ]; then
            SRC_FILES=$(find "$MODULE_DIR" -name "*.c" 2>/dev/null)
          fi
          
          if [ -z "$SRC_FILES" ]; then
            echo "❌ No source files found"
            return 1
          fi
          
          # Build object files one by one
          for SRC_FILE in $SRC_FILES; do
            local OBJ_FILE="${SRC_FILE%.c}.o"
            local OBJ_DIR=$(dirname "$OBJ_FILE")
            
            mkdir -p "$OBJ_DIR"
            
            echo "Compiling: $SRC_FILE"
            
            # Try to compile with simplified flags
            /usr/local/ollvm/bin/clang \
              -c "$SRC_FILE" \
              -o "$OBJ_FILE" \
              -I"$KERNEL_SRC/include" \
              -I"$KERNEL_SRC/arch/arm64/include" \
              -D__KERNEL__ \
              -DKBUILD_MODNAME=\"$(basename "$MODULE_DIR")\" \
              $OLLVM_FLAGS \
              2>&1 | tee -a "/tmp/individual_build.log"
          done
          
          # Try to link them (this is complex for kernel modules)
          echo "Note: Individual file compilation complete, but linking kernel modules is complex"
          echo "This approach may not produce a working module"
          return 1
        }
        
        # Function to build normally
        build_normal() {
          local MODULE_DIR="$1"
          echo "=== Building normally ==="
          
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/normal_build.log
        }
        
        # Function to apply binary obfuscation
        apply_binary_obfuscation() {
          local KO_FILE="$1"
          local LEVEL="$2"
          
          echo "=== Applying Binary Obfuscation (Level: $LEVEL) ==="
          
          # Make a backup
          cp "$KO_FILE" "$KO_FILE.backup"
          
          # Apply different obfuscation techniques based on level
          case "$LEVEL" in
            "light")
              echo "Light binary obfuscation: String encryption"
              encrypt_strings "$KO_FILE"
              ;;
              
            "medium")
              echo "Medium binary obfuscation: String encryption + simple transformations"
              encrypt_strings "$KO_FILE"
              apply_simple_transform "$KO_FILE"
              ;;
              
            "heavy")
              echo "Heavy binary obfuscation: Multiple transformations"
              encrypt_strings "$KO_FILE"
              apply_simple_transform "$KO_FILE"
              apply_xor_transform "$KO_FILE"
              ;;
              
            *)
              echo "No binary obfuscation"
              ;;
          esac
          
          # Verify the file is still valid
          if file "$KO_FILE" | grep -q "ELF"; then
            echo "✅ Binary obfuscation applied successfully"
          else
            echo "❌ Binary obfuscation corrupted the file, restoring backup"
            cp "$KO_FILE.backup" "$KO_FILE"
          fi
        }
        
        # Function to encrypt strings in binary
        encrypt_strings() {
          local KO_FILE="$1"
          
          echo "Encrypting strings in binary..."
          
          # Use Python with lief to manipulate ELF
          python3 -c "
import lief
import sys
import random

try:
    # Load the binary
    binary = lief.parse('$KO_FILE')
    
    if binary is None:
        print('Failed to parse ELF')
        sys.exit(1)
    
    # Get the .rodata section (contains strings)
    rodata = None
    for section in binary.sections:
        if section.name == '.rodata':
            rodata = section
            break
    
    if rodata is not None:
        print(f'Found .rodata section: 0x{rodata.virtual_address:x} - 0x{rodata.virtual_address + rodata.size:x}')
        
        # Simple XOR encryption of printable strings
        content = bytearray(rodata.content)
        changed = 0
        
        for i in range(len(content)):
            # Simple XOR with pattern for printable ASCII
            if 32 <= content[i] <= 126:
                content[i] ^= 0xAA
                changed += 1
        
        print(f'Encrypted {changed} bytes in .rodata')
        rodata.content = list(content)
        
        # Write back
        binary.write('$KO_FILE')
        print('String encryption complete')
    else:
        print('No .rodata section found')
        
except Exception as e:
    print(f'Error during string encryption: {e}')
    sys.exit(1)
" 2>&1 | tee -a /tmp/obfuscation.log
        }
        
        # Function to apply simple transformations
        apply_simple_transform() {
          local KO_FILE="$1"
          
          echo "Applying simple binary transformations..."
          
          # Simple byte shuffling in first 1KB
          python3 -c "
import sys
with open('$KO_FILE', 'rb') as f:
    data = bytearray(f.read())

# Only transform first 1KB to avoid breaking things
transform_len = min(1024, len(data))

# Simple byte swap every 4 bytes
for i in range(0, transform_len - 4, 4):
    data[i], data[i+1] = data[i+1], data[i]
    data[i+2], data[i+3] = data[i+3], data[i+2]

with open('$KO_FILE', 'wb') as f:
    f.write(data)

print(f'Transformed {transform_len} bytes')
" 2>&1 | tee -a /tmp/obfuscation.log
        }
        
        # Function to apply XOR transform
        apply_xor_transform() {
          local KO_FILE="$1"
          
          echo "Applying XOR transformation..."
          
          # XOR transform on code sections
          python3 -c "
import lief
import sys

try:
    binary = lief.parse('$KO_FILE')
    
    if binary is None:
        print('Failed to parse ELF')
        sys.exit(1)
    
    # Find executable sections
    for section in binary.sections:
        if section.has(lief.ELF.SECTION_FLAGS.EXECINSTR):
            print(f'Found executable section: {section.name}')
            
            content = bytearray(section.content)
            
            # XOR with pattern
            pattern = [0x90, 0x90, 0x90, 0x90]  # NOP sled pattern
            for i in range(len(content)):
                content[i] ^= pattern[i % len(pattern)]
            
            section.content = list(content)
            print(f'XOR transformed {len(content)} bytes in {section.name}')
    
    # Write back
    binary.write('$KO_FILE')
    print('XOR transformation complete')
    
except Exception as e:
    print(f'Error during XOR transformation: {e}')
" 2>&1 | tee -a /tmp/obfuscation.log
        }
        
        # Function to apply symbol obfuscation
        apply_symbol_obfuscation() {
          local KO_FILE="$1"
          local LEVEL="$2"
          
          echo "=== Applying Symbol Obfuscation (Level: $LEVEL) ==="
          
          # Use objcopy to strip/rename symbols
          case "$LEVEL" in
            "light"|"medium"|"heavy")
              echo "Stripping debug symbols..."
              llvm-strip -S "$KO_FILE" 2>/dev/null || true
              strip -S "$KO_FILE" 2>/dev/null || true
              
              echo "Randomizing section names..."
              randomize_section_names "$KO_FILE"
              ;;
          esac
        }
        
        # Function to randomize section names
        randomize_section_names() {
          local KO_FILE="$1"
          
          echo "Randomizing ELF section names..."
          
          python3 -c "
import lief
import random
import string

def random_name(length=8):
    return '.' + ''.join(random.choice(string.ascii_lowercase) for _ in range(length))

try:
    binary = lief.parse('$KO_FILE')
    
    if binary is None:
        print('Failed to parse ELF')
        sys.exit(1)

    
