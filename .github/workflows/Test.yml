name: Build Kernel Module ddk (OLLVM Levels)

on:
  workflow_dispatch:
    inputs:
      module_dir:
        description: 'Module directory'
        required: true
        type: choice
        options:
          - wuwa
        default: 'wuwa'

      # OLLVM Configuration Options
      obfuscation_level:
        description: 'OLLVM obfuscation strength'
        required: true
        type: choice
        options:
          - easy
          - medium
          - hard
          - extreme
        default: easy

      enable_fla:
        description: 'Enable Control Flow Flattening'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'yes'

      enable_split:
        description: 'Enable Basic Block Splitting'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'no'

      split_num:
        description: 'Splitting iterations (1-5)'
        required: true
        type: string
        default: '3'

      enable_sub:
        description: 'Enable Instruction Substitution'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'no'

      sub_loop:
        description: 'Substitution iterations (1-5)'
        required: true
        type: string
        default: '2'

      enable_bcf:
        description: 'Enable Bogus Control Flow'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'no'

      bcf_loop:
        description: 'BCF iterations (1-5)'
        required: true
        type: string
        default: '2'

      bcf_prob:
        description: 'BCF probability (1-100)'
        required: true
        type: string
        default: '40'

      enable_sobf:
        description: 'Enable String Obfuscation'
        required: true
        type: choice
        options:
          - 'yes'
          - 'no'
        default: 'no'

jobs:
  ddk-build:
    name: Build ${{ inputs.module_dir }} (${{ inputs.obfuscation_level }}) for ${{ matrix.kmi }}
    runs-on: ubuntu-latest

    strategy:
      matrix:
        kmi:
          - android12-5.10
          - android13-5.10
          - android13-5.15
          - android14-5.15
          - android14-6.1
          - android15-6.6
          - android16-6.12

    container:
      image: ghcr.io/ylarod/ddk:${{ matrix.kmi }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    # ==================================================
    # Install unzip and required tools
    # ==================================================
    - name: Install required tools
      run: |
        apt-get update
        apt-get install -y unzip file binutils findutils

    # ==================================================
    # Extract OLLVM toolchain directly
    # ==================================================
    - name: Extract OLLVM toolchain
      run: |
        set -e
        cd ${{ inputs.module_dir }}
        
        echo "=== Current directory structure ==="
        ls -la
        
        echo "=== Extracting OLLVM ZIPs ==="
        
        # Extract first ZIP directly
        echo "Extracting android-ollvm.zip..."
        unzip -q android-ollvm.zip
        
        # Extract second ZIP directly (will merge with first)
        echo "Extracting android-ollvm1.zip..."
        unzip -q -o android-ollvm1.zip
        
        echo "=== After extraction structure ==="
        ls -la android-ollvm/
        ls -la android-ollvm/bin/
        
        # Fix permissions on clang binary
        echo "=== Fixing permissions ==="
        chmod 755 android-ollvm/bin/clang
        chmod 755 android-ollvm/bin/clang++
        chmod 755 android-ollvm/bin/llvm-ar
        
        echo "OLLVM clang version:"
        ./android-ollvm/bin/clang --version | head -5

    # ==================================================
    # Find DDK clang location and replace with OLLVM clang
    # ==================================================
    - name: Locate and replace DDK clang with OLLVM clang
      run: |
        echo "=== LOCATING AND REPLACING DDK CLANG ==="
        cd ${{ inputs.module_dir }}
        
        # Step 1: Find DDK clang locations
        echo "=== Step 1: Finding DDK clang ==="
        
        # Look for DDK clang based on devcontainer config
        DDK_ROOT="${DDK_ROOT:-/opt/ddk}"
        echo "DDK_ROOT from env: $DDK_ROOT"
        
        # Search for clang in DDK directories
        DDK_CLANG_PATHS=()
        
        # Check DDK_ROOT
        if [ -d "$DDK_ROOT" ]; then
            echo "Searching in $DDK_ROOT..."
            DDK_CLANG_PATHS+=($(find "$DDK_ROOT" -name "clang" -type f -executable 2>/dev/null || true))
        fi
        
        # Also search in common DDK locations
        COMMON_DDK_PATHS=(
            "/opt/ddk"
            "/usr/local/ddk"
            "/ddk"
            "$HOME/ddk"
        )
        
        for path in "${COMMON_DDK_PATHS[@]}"; do
            if [ -d "$path" ]; then
                echo "Searching in $path..."
                DDK_CLANG_PATHS+=($(find "$path" -name "clang" -type f -executable 2>/dev/null || true))
            fi
        done
        
        # Also check environment variables
        echo "Checking environment variables..."
        echo "CLANG_PATH: ${CLANG_PATH:-not set}"
        echo "CC: ${CC:-not set}"
        echo "CROSS_COMPILE: ${CROSS_COMPILE:-not set}"
        
        # Check which clang is in PATH
        SYSTEM_CLANG=$(which clang 2>/dev/null || echo "")
        echo "System clang (from PATH): $SYSTEM_CLANG"
        
        # Check kernel build environment
        echo ""
        echo "=== Step 2: Checking kernel build environment ==="
        
        # Look for kernel build scripts that might set compiler
        if [ -d "$KERNEL_SRC" ]; then
            echo "Checking kernel source at $KERNEL_SRC"
            
            # Check for common kernel build configuration files
            KERNEL_CONFIGS=(
                "$KERNEL_SRC/Makefile"
                "$KERNEL_SRC/scripts/Kbuild.include"
                "$KERNEL_SRC/.config"
            )
            
            for config in "${KERNEL_CONFIGS[@]}"; do
                if [ -f "$config" ]; then
                    echo "Checking $config for compiler settings..."
                    grep -i "clang\|cc\|cross_compile" "$config" | head -5 || true
                fi
            done
        fi
        
        # Step 3: Build OLLVM flags
        echo ""
        echo "=== Step 3: Building OLLVM flags ==="
        
        # Build OLLVM flags from user inputs
        OLLVM_FLAGS=""
        OLLVM_DESCRIPTION=""
        
        # Control Flow Flattening
        if [ "${{ inputs.enable_fla }}" = "yes" ]; then
          OLLVM_FLAGS="$OLLVM_FLAGS -mllvm -fla"
          OLLVM_DESCRIPTION="$OLLVM_DESCRIPTION, Control Flow Flattening"
        fi
        
        # Basic Block Splitting
        if [ "${{ inputs.enable_split }}" = "yes" ]; then
          OLLVM_FLAGS="$OLLVM_FLAGS -mllvm -split -mllvm -split_num=${{ inputs.split_num }}"
          OLLVM_DESCRIPTION="$OLLVM_DESCRIPTION, Basic Block Splitting (iterations: ${{ inputs.split_num }})"
        fi
        
        # Instruction Substitution
        if [ "${{ inputs.enable_sub }}" = "yes" ]; then
          OLLVM_FLAGS="$OLLVM_FLAGS -mllvm -sub -mllvm -sub_loop=${{ inputs.sub_loop }}"
          OLLVM_DESCRIPTION="$OLLVM_DESCRIPTION, Instruction Substitution (iterations: ${{ inputs.sub_loop }})"
        fi
        
        # Bogus Control Flow
        if [ "${{ inputs.enable_bcf }}" = "yes" ]; then
          OLLVM_FLAGS="$OLLVM_FLAGS -mllvm -bcf -mllvm -bcf_loop=${{ inputs.bcf_loop }} -mllvm -bcf_prob=${{ inputs.bcf_prob }}"
          OLLVM_DESCRIPTION="$OLLVM_DESCRIPTION, Bogus Control Flow (iterations: ${{ inputs.bcf_loop }}, probability: ${{ inputs.bcf_prob }}%)"
        fi
        
        # String Obfuscation
        if [ "${{ inputs.enable_sobf }}" = "yes" ]; then
          OLLVM_FLAGS="$OLLVM_FLAGS -mllvm -sobf"
          OLLVM_DESCRIPTION="$OLLVM_DESCRIPTION, String Obfuscation"
        fi
        
        # Remove leading comma and space
        OLLVM_DESCRIPTION=${OLLVM_DESCRIPTION#, }
        
        echo "Custom OLLVM Flags: $OLLVM_FLAGS"
        if [ -n "$OLLVM_DESCRIPTION" ]; then
          echo "OLLVM Features: $OLLVM_DESCRIPTION"
        fi
        
        # Step 4: Create environment setup script
        echo ""
        echo "=== Step 4: Creating environment setup ==="
        
        # Create a script to set up the environment
        cat > /tmp/setup_ollvm_env.sh << 'EOF'
#!/bin/bash
# Setup OLLVM environment
        
echo "=== Setting up OLLVM environment ==="
        
# Get the module directory
MODULE_DIR="$PWD"
OLLVM_CLANG="$MODULE_DIR/android-ollvm/bin/clang"
OLLVM_CLANGPP="$MODULE_DIR/android-ollvm/bin/clang++"
OLLVM_AR="$MODULE_DIR/android-ollvm/bin/llvm-ar"
        
# Verify OLLVM clang exists
if [ ! -x "$OLLVM_CLANG" ]; then
    echo "ERROR: OLLVM clang not found at $OLLVM_CLANG" >&2
    exit 1
fi
        
echo "OLLVM clang path: $OLLVM_CLANG"
        
# Set OLLVM flags from environment or use defaults
OLLVM_FLAGS="${OLLVM_FLAGS:--mllvm -fla}"
echo "OLLVM flags: $OLLVM_FLAGS"
        
# Create a wrapper function for clang
ollvm_clang_wrapper() {
    echo "[OLLVM] Compiling: $@" >&2
    exec "$OLLVM_CLANG" $OLLVM_FLAGS "$@"
}
        
# Export the function
export -f ollvm_clang_wrapper
        
# Set environment variables
export REAL_CC="$OLLVM_CLANG"
export REAL_CXX="$OLLVM_CLANGPP"
export REAL_AR="$OLLVM_AR"
        
# For kernel build
export LLVM=1
export CLANG_TRIPLE="aarch64-linux-gnu-"
        
# Set PATH to prefer our OLLVM tools
export PATH="$MODULE_DIR/android-ollvm/bin:$PATH"
        
echo "Environment setup complete"
echo "PATH now starts with: $(echo $PATH | cut -d: -f1)"
EOF
        
        chmod +x /tmp/setup_ollvm_env.sh
        
        # Step 5: Create a direct clang replacement script
        echo ""
        echo "=== Step 5: Creating direct clang replacement ==="
        
        # Create a simple script that will be used as clang
        cat > /tmp/ollvm_clang << 'EOF'
#!/bin/bash
# Direct OLLVM clang replacement
        
# OLLVM clang path
OLLVM_CLANG="/__w/wuwa/wuwa/android-ollvm/bin/clang"
        
# OLLVM flags (can be overridden by environment)
OLLVM_FLAGS="${OLLVM_FLAGS:--mllvm -fla}"
        
# Check if OLLVM clang exists
if [ ! -x "$OLLVM_CLANG" ]; then
    echo "ERROR: OLLVM clang not found at $OLLVM_CLANG" >&2
    # Fall back to system clang
    exec /usr/bin/clang "$@"
fi
        
# Execute OLLVM clang with flags
exec "$OLLVM_CLANG" $OLLVM_FLAGS "$@"
EOF
        
        chmod +x /tmp/ollvm_clang
        
        # Export OLLVM flags
        export OLLVM_FLAGS="$OLLVM_FLAGS"
        
        # Set the main compiler to our OLLVM clang
        export CC="/__w/wuwa/wuwa/android-ollvm/bin/clang"
        export CXX="/__w/wuwa/wuwa/android-ollvm/bin/clang++"
        export AR="/__w/wuwa/wuwa/android-ollvm/bin/llvm-ar"
        
        # For kernel build
        export LLVM=1
        export CLANG_TRIPLE="aarch64-linux-gnu-"
        
        echo ""
        echo "=== Environment Summary ==="
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "AR: $AR"
        echo "LLVM: $LLVM"
        echo "OLLVM_FLAGS: $OLLVM_FLAGS"
        echo "PATH: $PATH"

    # ==================================================
    # Test OLLVM clang functionality
    # ==================================================
    - name: Test OLLVM clang
      run: |
        echo "=== TESTING OLLVM CLANG ==="
        cd ${{ inputs.module_dir }}
        
        # Test 1: Basic compilation
        echo "Test 1: Basic compilation with OLLVM"
        echo "int main() { return 0; }" > test.c
        if $CC -c test.c -o test.o 2>&1; then
            echo "✅ Basic compilation works"
            rm -f test.c test.o
        else
            echo "❌ Basic compilation failed"
            rm -f test.c test.o
            exit 1
        fi
        
        # Test 2: OLLVM flag test
        echo ""
        echo "Test 2: OLLVM flag test"
        echo "int test_ollvm() { return 42; }" > test_ollvm.c
        if $CC -mllvm -fla -c test_ollvm.c -o test_ollvm.o 2>&1; then
            echo "✅ OLLVM -fla flag works"
            
            # Check if object file was created
            if [ -f "test_ollvm.o" ]; then
                echo "Object file size: $(stat -c%s test_ollvm.o) bytes"
            fi
            rm -f test_ollvm.c test_ollvm.o
        else
            echo "❌ OLLVM -fla flag failed"
            rm -f test_ollvm.c test_ollvm.o
            # Try without -fla to see if clang works at all
            echo "Testing without -fla..."
            if $CC -c test_ollvm.c -o test_ollvm.o 2>&1; then
                echo "⚠️ Clang works but OLLVM flags don't"
            else
                echo "❌ Clang itself doesn't work"
            fi
            exit 1
        fi
        
        # Test 3: Verify it's really OLLVM clang
        echo ""
        echo "Test 3: Verifying OLLVM version"
        if $CC --version 2>&1 | grep -i "ollvm\|obfuscator"; then
            echo "✅ This is an OLLVM/obfuscator version of clang"
        else
            echo "⚠️ This doesn't appear to be OLLVM clang (checking version info)"
            $CC --version 2>&1 | head -5
        fi
        
        echo ""
        echo "✅ All OLLVM tests passed!"

    # ==================================================
    # Build module with OLLVM clang
    # ==================================================
    - name: Build module with OLLVM clang
      run: |
        echo "=== BUILDING MODULE WITH OLLVM CLANG ==="
        echo "Module directory: ${{ inputs.module_dir }}"
        echo "Kernel source: $KERNEL_SRC"
        echo "Using CC: $CC"
        
        cd ${{ inputs.module_dir }}
        
        # Clean first
        echo ""
        echo "=== Cleaning previous build ==="
        make -C $KERNEL_SRC M=$PWD clean 2>&1 | tail -20 || true
        
        # Build with verbose output
        echo ""
        echo "=== Starting build ==="
        
        # First, let's see what the kernel build system thinks about our compiler
        echo "Checking kernel build configuration..."
        make -C $KERNEL_SRC M=$PWD V=1 dummy 2>&1 | grep -i "cc\|clang\|compiler" | head -10 || true
        
        # Now build the actual module
        echo ""
        echo "Building module..."
        
        # Capture full build log
        make -C $KERNEL_SRC M=$PWD V=1 modules 2>&1 | tee build.log
        
        BUILD_STATUS=${PIPESTATUS[0]}
        
        # Check build result
        echo ""
        echo "=== Build Result ==="
        
        if [ $BUILD_STATUS -eq 0 ]; then
            echo "✅ Build completed successfully!"
        else
            echo "❌ Build failed with status: $BUILD_STATUS"
            echo "Last 100 lines of build log:"
            tail -100 build.log
            exit 1
        fi
        
        # Verify OLLVM was used
        echo ""
        echo "=== Verifying OLLVM Usage ==="
        
        OLLVM_USAGE_COUNT=$(grep -c "android-ollvm/bin/clang" build.log || echo "0")
        if [ $OLLVM_USAGE_COUNT -gt 0 ]; then
            echo "✅ OLLVM clang was used $OLLVM_USAGE_COUNT times"
            echo "Sample compile commands:"
            grep "android-ollvm/bin/clang" build.log | head -3
        else
            echo "⚠️ OLLVM clang not detected in build log"
            echo "Checking what compiler was used:"
            grep "clang" build.log | head -5 || echo "No clang commands found"
            
            # Check if CC variable was used
            echo "Checking for CC variable usage:"
            grep "CC=" build.log | head -5 || true
        fi
        
        # Find the kernel module
        KO_FILE=$(find . -name "*.ko" -type f | head -1)
        if [ -z "$KO_FILE" ]; then
            echo "❌ ERROR: No .ko file found!"
            exit 1
        fi
        
        echo ""
        echo "✅ Found kernel module: $(basename "$KO_FILE")"
        echo "Location: $KO_FILE"
        echo "Size: $(du -h "$KO_FILE" | cut -f1)"

    # ==================================================
    # Analyze and package the module
    # ==================================================
    - name: Analyze and package module
      run: |
        cd ${{ inputs.module_dir }}
        
        KO_FILE=$(find . -name "*.ko" -type f | head -1)
        if [ -z "$KO_FILE" ]; then
            echo "❌ No .ko file found!"
            exit 1
        fi
        
        echo "=== Analyzing Built Module ==="
        
        # Basic file info
        echo "File type:"
        file "$KO_FILE"
        
        echo ""
        echo "Size: $(du -h "$KO_FILE" | cut -f1)"
        
        # Check for OLLVM patterns if objdump is available
        if command -v objdump &> /dev/null; then
            echo ""
            echo "=== Checking for OLLVM patterns ==="
            
            # Extract text section size
            TEXT_SIZE=$(objdump -h "$KO_FILE" 2>/dev/null | grep "\.text" | awk '{print $3}' | head -1 || echo "0")
            if [ "$TEXT_SIZE" != "0" ]; then
                TEXT_SIZE_DEC=$((0x$TEXT_SIZE))
                echo "Text section size: $TEXT_SIZE_DEC bytes"
            fi
            
            # Count basic blocks
            echo "Basic block count (approx):"
            objdump -d "$KO_FILE" 2>/dev/null | grep -c "^[0-9a-f]* <.*>:" || echo "Could not disassemble"
        fi
        
        # Create output directory
        mkdir -p /github/workspace/out
        
        # Generate output filename
        TS=$(date +'%Y%m%d-%H%M%S')
        OUT_NAME="${{ inputs.module_dir }}-${{ matrix.kmi }}-${{ inputs.obfuscation_level }}-$TS.ko"
        OUT_PATH="/github/workspace/out/$OUT_NAME"
        
        # Copy module
        cp "$KO_FILE" "$OUT_PATH"
        
        # Strip debug symbols
        echo ""
        echo "=== Stripping debug symbols ==="
        echo "Before strip: $(du -h "$OUT_PATH" | cut -f1)"
        
        if command -v llvm-strip &> /dev/null; then
            llvm-strip -d "$OUT_PATH"
            echo "Stripped with llvm-strip"
        elif command -v strip &> /dev/null; then
            strip --strip-debug "$OUT_PATH"
            echo "Stripped with strip"
        else
            echo "No strip tool found, keeping debug symbols"
        fi
        
        echo "After strip: $(du -h "$OUT_PATH" | cut -f1)"
        
        # Create build info file
        BUILD_INFO="/github/workspace/out/build-info.txt"
        echo "=== Build Information ===" > "$BUILD_INFO"
        echo "Module: ${{ inputs.module_dir }}" >> "$BUILD_INFO"
        echo "KMI: ${{ matrix.kmi }}" >> "$BUILD_INFO"
        echo "OLLVM Level: ${{ inputs.obfuscation_level }}" >> "$BUILD_INFO"
        echo "Build Time: $(date)" >> "$BUILD_INFO"
        echo "Output File: $OUT_NAME" >> "$BUILD_INFO"
        echo "" >> "$BUILD_INFO"
        echo "=== OLLVM Configuration ===" >> "$BUILD_INFO"
        echo "Control Flow Flattening: ${{ inputs.enable_fla }}" >> "$BUILD_INFO"
        echo "Basic Block Splitting: ${{ inputs.enable_split }}" >> "$BUILD_INFO"
        [ "${{ inputs.enable_split }}" = "yes" ] && echo "  Iterations: ${{ inputs.split_num }}" >> "$BUILD_INFO"
        echo "Instruction Substitution: ${{ inputs.enable_sub }}" >> "$BUILD_INFO"
        [ "${{ inputs.enable_sub }}" = "yes" ] && echo "  Iterations: ${{ inputs.sub_loop }}" >> "$BUILD_INFO"
        echo "Bogus Control Flow: ${{ inputs.enable_bcf }}" >> "$BUILD_INFO"
        [ "${{ inputs.enable_bcf }}" = "yes" ] && echo "  Iterations: ${{ inputs.bcf_loop }}, Probability: ${{ inputs.bcf_prob }}%" >> "$BUILD_INFO"
        echo "String Obfuscation: ${{ inputs.enable_sobf }}" >> "$BUILD_INFO"
        echo "" >> "$BUILD_INFO"
        echo "=== Compiler Information ===" >> "$BUILD_INFO"
        $CC --version 2>&1 | head -3 >> "$BUILD_INFO"
        
        echo ""
        echo "=== BUILD COMPLETE ==="
        echo "Output: $OUT_NAME"
        echo "Build info saved to: $(basename "$BUILD_INFO")"
        echo ""
        echo "✅ Module successfully built with OLLVM!"

    # ==================================================
    # Upload artifact
    # ==================================================
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}-${{ inputs.obfuscation_level }}
        path: |
          /github/workspace/out/*.ko
          /github/workspace/out/build-info.txt
        
    # ==================================================
    # Upload build logs
    # ==================================================
    - name: Upload build logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}-logs
        path: ${{ inputs.module_dir }}/build.log
