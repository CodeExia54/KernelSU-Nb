name: Build Kernel Module with OLLVM

on:
  workflow_dispatch:
    inputs:
      module_dir:
        description: 'Module directory to build'
        required: true
        type: choice
        options:
        - exianb-dev
        - exianb
        - ovo
        - prctl-fd
        - prctl-hook
        - offset
        - hello-world
        - wuwa
        - panic
        default: 'exianb-dev'
      obfuscation_level:
        description: 'OLLVM obfuscation level'
        required: false
        default: 'medium'
        type: choice
        options:
        - none
        - light
        - medium
        - heavy
      use_custom_clang:
        description: 'Use custom OLLVM clang from ZIP'
        required: false
        default: 'false'
        type: boolean

jobs:
  ddk-build:
    name: Build ${{ inputs.module_dir }}.ko for ${{ matrix.kmi }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        kmi:
          - android12-5.10
          - android13-5.10
          - android13-5.15
          - android14-5.15
          - android14-6.1
          - android15-6.6
          - android16-6.12

    container:
      image: ghcr.io/ylarod/ddk:${{ matrix.kmi }}

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4

    - name: Install unzip in container
      run: |
        echo "=== Installing unzip ==="
        apt-get update && apt-get install -y unzip

    - name: Extract and Combine OLLVM Toolchain from Multiple ZIPs
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Extracting and Combining OLLVM Toolchain ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Create OLLVM directory
        mkdir -p /usr/local/ollvm/bin
        
        # List all clang*.zip files
        echo "Looking for clang*.zip files in $MODULE_DIR/"
        ZIP_FILES=$(find "$MODULE_DIR" -name "clang*.zip" | sort)
        
        if [ -z "$ZIP_FILES" ]; then
          echo "❌ No clang*.zip files found in $MODULE_DIR/"
          exit 1
        fi
        
        echo "Found ZIP files:"
        echo "$ZIP_FILES"
        
        # Extract each ZIP file
        ZIP_COUNT=0
        for zip_file in $ZIP_FILES; do
          ZIP_COUNT=$((ZIP_COUNT + 1))
          echo ""
          echo "=== Extracting ZIP $ZIP_COUNT: $(basename "$zip_file") ==="
          
          # Create temp directory for this zip
          TEMP_DIR="/tmp/ollvm_extract_$ZIP_COUNT"
          mkdir -p "$TEMP_DIR"
          
          # Extract to temp directory
          unzip -q "$zip_file" -d "$TEMP_DIR"
          
          # Find and copy all binaries from this zip
          echo "Looking for binaries in extracted files..."
          
          # Method 1: Look for bin/ directory
          if [ -d "$TEMP_DIR/bin" ]; then
            echo "Found bin/ directory, copying files..."
            find "$TEMP_DIR/bin" -type f -executable -exec cp {} /usr/local/ollvm/bin/ \; 2>/dev/null || true
          fi
          
          # Method 2: Look for loose binaries
          echo "Looking for loose binaries..."
          find "$TEMP_DIR" -type f -executable -name "*" ! -path "*/.*" -exec cp {} /usr/local/ollvm/bin/ \; 2>/dev/null || true
          
          # Clean up temp directory
          rm -rf "$TEMP_DIR"
          
          echo "ZIP $ZIP_COUNT extraction complete"
        done
        
        echo ""
        echo "=== Extraction Complete ==="
        echo "Extracted $ZIP_COUNT ZIP file(s)"
        echo ""
        
        # Make all binaries executable
        chmod -R +x /usr/local/ollvm/bin/ 2>/dev/null || true
        
        # List what we got
        echo "=== Binaries in /usr/local/ollvm/bin/ ==="
        ls -la /usr/local/ollvm/bin/ | head -30
        echo "..."
        FILE_COUNT=$(ls -1 /usr/local/ollvm/bin/ 2>/dev/null | wc -l)
        echo "Total binaries: $FILE_COUNT"
        
        # Check for essential tools
        echo ""
        echo "=== Essential Tools Check ==="
        
        ESSENTIAL_TOOLS=("clang" "ld.lld")
        ALL_ESSENTIAL_FOUND=1
        
        for tool in "${ESSENTIAL_TOOLS[@]}"; do
          if [ -f "/usr/local/ollvm/bin/$tool" ]; then
            echo "✅ $tool: FOUND"
            # Test it
            echo "  Version: $(/usr/local/ollvm/bin/$tool --version 2>&1 | head -1)"
          else
            echo "❌ $tool: MISSING"
            ALL_ESSENTIAL_FOUND=0
          fi
        done
        
        if [ $ALL_ESSENTIAL_FOUND -eq 0 ]; then
          echo ""
          echo "❌ Missing essential tools!"
          echo "Looking for alternative locations..."
          
          # Search entire filesystem for missing tools
          for tool in "${ESSENTIAL_TOOLS[@]}"; do
            if [ ! -f "/usr/local/ollvm/bin/$tool" ]; then
              FOUND=$(find /usr/local/ollvm -name "$tool" -type f 2>/dev/null | head -1)
              if [ -n "$FOUND" ]; then
                echo "Found $tool at: $FOUND"
                cp "$FOUND" /usr/local/ollvm/bin/
                chmod +x "/usr/local/ollvm/bin/$tool"
              fi
            fi
          done
        fi
        
        # Add to PATH globally
        echo 'export PATH=/usr/local/ollvm/bin:$PATH' >> /etc/profile.d/ollvm.sh
        export PATH=/usr/local/ollvm/bin:$PATH
        
        echo "OLLVM_TOOLCHAIN_INSTALLED=true" >> $GITHUB_ENV

    - name: Verify Toolchain Setup
      run: |
        echo "=== Toolchain Verification ==="
        echo "PATH: $PATH"
        echo ""
        
        # List all available tools
        echo "Available OLLVM tools:"
        ls /usr/local/ollvm/bin/ 2>/dev/null | sort | tr '\n' ' '
        echo ""
        
        # Test basic compilation
        if command -v clang >/dev/null 2>&1; then
          echo "Testing clang compilation..."
          echo 'int test() { return 0; }' > /tmp/test_compile.c
          clang -c /tmp/test_compile.c -o /tmp/test_compile.o 2>&1 && \
            echo "✅ Compilation test passed" || echo "❌ Compilation test failed"
        fi

    - name: Build with OLLVM Toolchain
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Building ${{ inputs.module_dir }}.ko ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Verify essential tools exist
        if [ ! -f "/usr/local/ollvm/bin/clang" ]; then
          echo "❌ clang not found in OLLVM toolchain!"
          exit 1
        fi
        
        # Set OLLVM flags
        case "${{ inputs.obfuscation_level }}" in
          "light")
            OLLVM_FLAGS="-mllvm -fla"
            echo "OLLVM Level: light (-fla)"
            ;;
          "medium")
            OLLVM_FLAGS="-mllvm -fla -mllvm -sub"
            echo "OLLVM Level: medium (-fla -sub)"
            ;;
          "heavy")
            OLLVM_FLAGS="-mllvm -fla -mllvm -sub -mllvm -bcf"
            echo "OLLVM Level: heavy (-fla -sub -bcf)"
            ;;
          *)
            OLLVM_FLAGS=""
            echo "OLLVM Level: none"
            ;;
        esac
        
        echo ""
        echo "=== Tool Configuration ==="
        
        # Essential tools (must have)
        CC="/usr/local/ollvm/bin/clang $OLLVM_FLAGS"
        echo "CC: $CC"
        
        # Check for optional tools, use if available
        if [ -f "/usr/local/ollvm/bin/ld.lld" ]; then
          LD="/usr/local/ollvm/bin/ld.lld"
          echo "LD: $LD"
        else
          echo "⚠️ ld.lld not found, will use default linker"
          LD=""  # Let make use default
        fi
        
        TOOL_VARS="CC=\"$CC\""
        if [ -n "$LD" ]; then
          TOOL_VARS="$TOOL_VARS LD=\"$LD\""
        fi
        
        # Add optional tools if found
        for tool in ar nm objcopy strip; do
          if [ -f "/usr/local/ollvm/bin/llvm-$tool" ]; then
            TOOL_VARS="$TOOL_VARS $(echo $tool | tr '[:lower:]' '[:upper:]')=\"/usr/local/ollvm/bin/llvm-$tool\""
            echo "$(echo $tool | tr '[:lower:]' '[:upper:]'): /usr/local/ollvm/bin/llvm-$tool"
          fi
        done
        
        echo ""
        echo "=== Build Command ==="
        echo "make -C \"$KERNEL_SRC\" M=\"$PWD/$MODULE_DIR\" modules $TOOL_VARS HOSTCC=\"gcc\" HOSTCXX=\"g++\" -j\$(nproc)"
        
        # Clean first
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
        
        # Build with LTO first (if we have ld.lld)
        if [ -f "/usr/local/ollvm/bin/ld.lld" ]; then
          echo ""
          echo "=== Attempt 1: Build with LTO ==="
          
          set +e
          eval make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
            $TOOL_VARS \
            HOSTCC="gcc" \
            HOSTCXX="g++" \
            -j$(nproc) 2>&1 | tee /tmp/build_lto.log
          LTO_EXIT=$?
          set -e
          
          if [ $LTO_EXIT -eq 0 ] && [ -f "$MODULE_DIR"/*.ko ]; then
            echo "✅ LTO build successful!"
            cp /tmp/build_lto.log /tmp/build.log
          else
            echo "❌ LTO build failed, trying without LTO"
          fi
        fi
        
        # If LTO failed or we don't have ld.lld, try without LTO
        if [ ! -f "/usr/local/ollvm/bin/ld.lld" ] || [ ! -f "$MODULE_DIR"/*.ko ]; then
          echo ""
          echo "=== Attempt 2: Build without LTO ==="
          
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
          
          # Build without LTO
          eval make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
            CC="/usr/local/ollvm/bin/clang $OLLVM_FLAGS -fno-lto" \
            HOSTCC="gcc" \
            HOSTCXX="g++" \
            -j$(nproc) 2>&1 | tee /tmp/build_no_lto.log
          
          cp /tmp/build_no_lto.log /tmp/build.log
        fi

    - name: Build with Default Toolchain
      if: ${{ !inputs.use_custom_clang }}
      run: |
        echo "=== Building with Default Toolchain ==="
        MODULE_DIR="${{ inputs.module_dir }}"
        
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/build.log

    - name: Check Build Result
      run: |
        echo "=== Checking Build Result ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Find the .ko file
        KO_FILE=$(find "$MODULE_DIR" -name "*.ko" -type f | head -1)
        
        if [ -f "$KO_FILE" ]; then
          echo "✅ Build successful! Found: $KO_FILE"
          echo "FILE_EXISTS=true" >> $GITHUB_ENV
          echo "KO_FILE_PATH=$KO_FILE" >> $GITHUB_ENV
          
          # Show module info
          echo ""
          echo "=== Module Information ==="
          ls -lh "$KO_FILE"
          
          # Check OLLVM usage
          if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
            echo ""
            echo "=== OLLVM Verification ==="
            if grep -q "mllvm" /tmp/build.log 2>/dev/null; then
              echo "✅ OLLVM flags were used"
            else
              echo "⚠️ No OLLVM flags found in build log"
            fi
          fi
        else
          echo "❌ Build failed! No .ko file found."
          echo "FILE_EXISTS=false" >> $GITHUB_ENV
          
          # Show error summary
          echo ""
          echo "=== Error Summary ==="
          tail -30 /tmp/build.log 2>/dev/null || echo "No build log found"
        fi

    - name: Process and Upload Artifact
      if: env.FILE_EXISTS == 'true'
      run: |
        MODULE_DIR="${{ inputs.module_dir }}"
        KO_FILE="${{ env.KO_FILE_PATH }}"
        
        TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
        
        # Create descriptive filename
        if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
          if grep -q "fno-lto" /tmp/build.log 2>/dev/null; then
            OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-ollvm-${{ inputs.obfuscation_level }}-noLTO-$TIMESTAMP.ko"
          else
            OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-ollvm-${{ inputs.obfuscation_level }}-LTO-$TIMESTAMP.ko"
          fi
        else
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-default-$TIMESTAMP.ko"
        fi
        
        mkdir -p /github/workspace/out
        cp "$KO_FILE" "/github/workspace/out/$OUTPUT_NAME"
        
        echo "✅ Saved as: $OUTPUT_NAME"
        echo "ARTIFACT_PATH=/github/workspace/out/$OUTPUT_NAME" >> $GITHUB_ENV

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}
        path: ${{ env.ARTIFACT_PATH }}
        retention-days: 7
      if: env.FILE_EXISTS == 'true'

    - name: Upload Build Logs
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}-logs
        path: /tmp/build*.log
        retention-days: 7
      if: always()
