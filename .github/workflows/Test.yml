name: Build Kernel Module with OLLVM

on:
  workflow_dispatch:
    inputs:
      module_dir:
        description: 'Module directory to build'
        required: true
        type: choice
        options:
        - exianb-dev
        - exianb
        - ovo
        - prctl-fd
        - prctl-hook
        - offset
        - hello-world
        - wuwa
        - panic
        default: 'exianb-dev'
      obfuscation_level:
        description: 'OLLVM obfuscation level'
        required: false
        default: 'medium'
        type: choice
        options:
        - none
        - light
        - medium
        - heavy
      use_custom_clang:
        description: 'Use custom OLLVM clang from ZIP'
        required: false
        default: 'false'
        type: boolean

jobs:
  ddk-build:
    name: Build ${{ inputs.module_dir }}.ko for ${{ matrix.kmi }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        kmi:
          - android12-5.10
          - android13-5.10
          - android13-5.15
          - android14-5.15
          - android14-6.1
          - android15-6.6
          - android16-6.12

    container:
      image: ghcr.io/ylarod/ddk:${{ matrix.kmi }}

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        apt-get update && apt-get install -y \
          unzip \
          file \
          python3 \
          python3-pip \
          xxd
        pip3 install lief

    - name: Extract OLLVM Toolchain
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Extracting OLLVM Toolchain ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean any existing ollvm directory
        rm -rf /usr/local/ollvm
        mkdir -p /usr/local/ollvm
        
        # Find and extract ZIP files
        ZIP_COUNT=0
        for zip_file in "$MODULE_DIR"/clang*.zip; do
          if [ -f "$zip_file" ]; then
            ZIP_COUNT=$((ZIP_COUNT + 1))
            echo "=== Extracting $(basename "$zip_file") ==="
            unzip -q "$zip_file" -d /usr/local/ollvm/
          fi
        done
        
        if [ $ZIP_COUNT -eq 0 ]; then
          echo "❌ No clang*.zip files found in $MODULE_DIR/"
          exit 1
        fi
        
        # Organize binaries
        echo ""
        echo "=== Organizing Binaries ==="
        
        # Create bin directory
        mkdir -p /usr/local/ollvm/bin
        
        # Move all executables to bin/
        find /usr/local/ollvm -type f -executable -exec mv {} /usr/local/ollvm/bin/ \; 2>/dev/null || true
        
        # Make everything executable
        chmod -R +x /usr/local/ollvm/bin/ 2>/dev/null || true
        
        # Test clang
        echo ""
        echo "=== Testing OLLVM Clang ==="
        if [ -f "/usr/local/ollvm/bin/clang" ]; then
          echo "✅ OLLVM clang found"
          /usr/local/ollvm/bin/clang --version | head -3
        else
          echo "❌ clang not found in /usr/local/ollvm/bin/"
          exit 1
        fi
        
        # Add to PATH
        export PATH=/usr/local/ollvm/bin:$PATH
        echo 'export PATH=/usr/local/ollvm/bin:$PATH' >> /etc/profile.d/ollvm.sh

    - name: Create Obfuscation Scripts
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Creating Obfuscation Scripts ==="
        
        # Create string encryption script
        cat > /tmp/encrypt_strings.py << 'PYEOF'
import lief
import sys
import os

def encrypt_strings(ko_file):
    try:
        # Load the binary
        binary = lief.parse(ko_file)
        
        if binary is None:
            print('Failed to parse ELF')
            return False
        
        # Get the .rodata section (contains strings)
        rodata = None
        for section in binary.sections:
            if section.name == '.rodata':
                rodata = section
                break
        
        if rodata is not None:
            print(f'Found .rodata section: 0x{rodata.virtual_address:x} - 0x{rodata.virtual_address + rodata.size:x}')
            
            # Simple XOR encryption of printable strings
            content = bytearray(rodata.content)
            changed = 0
            
            for i in range(len(content)):
                # Simple XOR with pattern for printable ASCII
                if 32 <= content[i] <= 126:
                    content[i] ^= 0xAA
                    changed += 1
            
            print(f'Encrypted {changed} bytes in .rodata')
            rodata.content = list(content)
            
            # Write back
            binary.write(ko_file)
            print('String encryption complete')
            return True
        else:
            print('No .rodata section found')
            return False
            
    except Exception as e:
        print(f'Error during string encryption: {e}')
        return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 encrypt_strings.py <ko_file>")
        sys.exit(1)
    
    ko_file = sys.argv[1]
    if encrypt_strings(ko_file):
        sys.exit(0)
    else:
        sys.exit(1)
PYEOF

        # Create binary transformation script
        cat > /tmp/transform_binary.py << 'PYEOF'
import sys

def transform_binary(ko_file):
    try:
        with open(ko_file, 'rb') as f:
            data = bytearray(f.read())

        # Only transform first 1KB to avoid breaking things
        transform_len = min(1024, len(data))

        # Simple byte swap every 4 bytes
        for i in range(0, transform_len - 4, 4):
            data[i], data[i+1] = data[i+1], data[i]
            data[i+2], data[i+3] = data[i+3], data[i+2]

        with open(ko_file, 'wb') as f:
            f.write(data)

        print(f'Transformed {transform_len} bytes')
        return True
        
    except Exception as e:
        print(f'Error during binary transformation: {e}')
        return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 transform_binary.py <ko_file>")
        sys.exit(1)
    
    ko_file = sys.argv[1]
    if transform_binary(ko_file):
        sys.exit(0)
    else:
        sys.exit(1)
PYEOF

        # Create section XOR script
        cat > /tmp/xor_sections.py << 'PYEOF'
import lief
import sys

def xor_sections(ko_file):
    try:
        binary = lief.parse(ko_file)
        
        if binary is None:
            print('Failed to parse ELF')
            return False
        
        # Find executable sections
        transformed = 0
        for section in binary.sections:
            if section.has(lief.ELF.SECTION_FLAGS.EXECINSTR):
                print(f'Found executable section: {section.name}')
                
                content = bytearray(section.content)
                
                # XOR with pattern
                pattern = [0x90, 0x90, 0x90, 0x90]  # NOP sled pattern
                for i in range(len(content)):
                    content[i] ^= pattern[i % len(pattern)]
                
                section.content = list(content)
                transformed += len(content)
                print(f'XOR transformed {len(content)} bytes in {section.name}')
        
        if transformed > 0:
            # Write back
            binary.write(ko_file)
            print(f'XOR transformation complete: {transformed} total bytes')
            return True
        else:
            print('No executable sections found')
            return False
            
    except Exception as e:
        print(f'Error during XOR transformation: {e}')
        return False

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 xor_sections.py <ko_file>")
        sys.exit(1)
    
    ko_file = sys.argv[1]
    if xor_sections(ko_file):
        sys.exit(0)
    else:
        sys.exit(1)
PYEOF

        echo "✅ Obfuscation scripts created"

    - name: Build Kernel Module
      run: |
        echo "=== Building ${{ inputs.module_dir }}.ko ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean first
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
        
        # Try OLLVM build first if requested
        if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
          echo "=== Attempting OLLVM Build ==="
          
          # Set OLLVM flags based on level
          case "${{ inputs.obfuscation_level }}" in
            "light")
              OLLVM_FLAGS="-mllvm -fla"
              echo "OLLVM Level: light (flags: -fla)"
              ;;
            "medium")
              OLLVM_FLAGS="-mllvm -fla -mllvm -sub"
              echo "OLLVM Level: medium (flags: -fla -sub)"
              ;;
            "heavy")
              OLLVM_FLAGS="-mllvm -fla -mllvm -sub -mllvm -bcf"
              echo "OLLVM Level: heavy (flags: -fla -sub -bcf)"
              ;;
            *)
              OLLVM_FLAGS=""
              echo "OLLVM Level: none"
              ;;
          esac
          
          # Try with KCFLAGS
          echo "Attempting build with OLLVM flags..."
          set +e
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
            KCFLAGS="$OLLVM_FLAGS -fno-lto -fno-sanitize=cfi" \
            -j$(nproc) 2>&1 | tee /tmp/ollvm_build.log
          OLLVM_RESULT=$?
          set -e
          
          if [ $OLLVM_RESULT -ne 0 ]; then
            echo "❌ OLLVM build failed, falling back to normal build"
            make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
            make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/normal_build.log
          else
            echo "✅ OLLVM build successful"
          fi
        else
          # Build normally
          echo "=== Building normally ==="
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/normal_build.log
        fi
        
        # Check if build was successful
        KO_FILE=$(find "$MODULE_DIR" -name "*.ko" -type f | head -1)
        
        if [ -f "$KO_FILE" ]; then
          echo "✅ Build successful: $KO_FILE"
          cp "$KO_FILE" "$KO_FILE.original"
          echo "ORIGINAL_KO=$KO_FILE.original" >> $GITHUB_ENV
          echo "FINAL_KO=$KO_FILE" >> $GITHUB_ENV
        else
          echo "❌ Build failed: No .ko file found"
          exit 1
        fi

    - name: Apply Obfuscation
      if: ${{ inputs.use_custom_clang && success() }}
      run: |
        echo "=== Applying Obfuscation ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        ORIGINAL_KO="${{ env.ORIGINAL_KO }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        OBF_LEVEL="${{ inputs.obfuscation_level }}"
        
        if [ ! -f "$ORIGINAL_KO" ] || [ ! -f "$FINAL_KO" ]; then
          echo "❌ Kernel module files not found"
          exit 1
        fi
        
        # Make a backup
        cp "$FINAL_KO" "$FINAL_KO.backup"
        
        # Apply obfuscation based on level
        case "$OBF_LEVEL" in
          "light")
            echo "=== Light Obfuscation ==="
            echo "Applying string encryption..."
            python3 /tmp/encrypt_strings.py "$FINAL_KO"
            ;;
            
          "medium")
            echo "=== Medium Obfuscation ==="
            echo "Applying string encryption..."
            python3 /tmp/encrypt_strings.py "$FINAL_KO"
            echo "Applying binary transformations..."
            python3 /tmp/transform_binary.py "$FINAL_KO"
            ;;
            
          "heavy")
            echo "=== Heavy Obfuscation ==="
            echo "Applying string encryption..."
            python3 /tmp/encrypt_strings.py "$FINAL_KO"
            echo "Applying binary transformations..."
            python3 /tmp/transform_binary.py "$FINAL_KO"
            echo "Applying section XOR..."
            python3 /tmp/xor_sections.py "$FINAL_KO"
            ;;
            
          *)
            echo "=== No Obfuscation ==="
            ;;
        esac
        
        # Verify the file is still valid
        echo "=== Verifying Obfuscated Module ==="
        
        if [ ! -f "$FINAL_KO" ]; then
          echo "❌ Obfuscated file does not exist"
          exit 1
        fi
        
        if file "$FINAL_KO" | grep -q "ELF"; then
          echo "✅ File is still valid ELF"
        else
          echo "❌ File is not valid ELF after obfuscation, restoring backup"
          cp "$FINAL_KO.backup" "$FINAL_KO"
        fi
        
        # Check size
        ORIG_SIZE=$(stat -c%s "$ORIGINAL_KO")
        NEW_SIZE=$(stat -c%s "$FINAL_KO")
        
        echo "Original size: $ORIG_SIZE bytes"
        echo "New size: $NEW_SIZE bytes"
        
        # Check if file was modified
        if cmp -s "$ORIGINAL_KO" "$FINAL_KO"; then
          echo "⚠️ File was not modified by obfuscation"
        else
          echo "✅ File was modified by obfuscation"
        fi

    - name: Create Final Artifact
      run: |
        echo "=== Creating Final Artifact ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        
        if [ ! -f "$FINAL_KO" ]; then
          echo "❌ Final kernel module not found"
          exit 1
        fi
        
        TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
        
        if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
          OBF_LEVEL="${{ inputs.obfuscation_level }}"
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-ollvm-$OBF_LEVEL-$TIMESTAMP.ko"
        else
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-default-$TIMESTAMP.ko"
        fi
        
        mkdir -p /github/workspace/out
        cp "$FINAL_KO" "/github/workspace/out/$OUTPUT_NAME"
        
        # Strip debug symbols to reduce size
        echo "Stripping debug symbols..."
        llvm-strip -d "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        strip --strip-debug "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        echo "Warning: Could not strip debug symbols"
        
        echo "Final module: $OUTPUT_NAME"
        echo "Size: $(du -h "/github/workspace/out/$OUTPUT_NAME" | cut -f1)"
        echo "ARTIFACT_PATH=/github/workspace/out/$OUTPUT_NAME" >> $GITHUB_ENV

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}
        path: ${{ env.ARTIFACT_PATH }}
        retention-days: 7

    - name: Upload Build Logs
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}-logs
        path: /tmp/build*.log
        retention-days: 7
      if: always()
