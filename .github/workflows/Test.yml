name: Build Kernel Module with OLLVM

on:
  workflow_dispatch:
    inputs:
      module_dir:
        description: 'Module directory to build'
        required: true
        type: choice
        options:
        - exianb-dev
        - exianb
        - ovo
        - prctl-fd
        - prctl-hook
        - offset
        - hello-world
        - wuwa
        - panic
        default: 'exianb-dev'
      obfuscation_level:
        description: 'OLLVM obfuscation level'
        required: false
        default: 'medium'
        type: choice
        options:
        - none
        - light
        - medium
        - heavy
      use_custom_clang:
        description: 'Use custom OLLVM clang from ZIP'
        required: false
        default: 'false'
        type: boolean
      obfuscation_strategy:
        description: 'Obfuscation strategy when OLLVM fails'
        required: false
        default: 'binary'
        type: choice
        options:
        - try_ollvm_first
        - binary_only
        - symbolic_only
        - hybrid

jobs:
  ddk-build:
    name: Build ${{ inputs.module_dir }}.ko for ${{ matrix.kmi }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        kmi:
          - android12-5.10
          - android13-5.10
          - android13-5.15
          - android14-5.15
          - android14-6.1
          - android15-6.6
          - android16-6.12

    container:
      image: ghcr.io/ylarod/ddk:${{ matrix.kmi }}

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        apt-get update && apt-get install -y \
          unzip \
          file \
          python3 \
          python3-pip \
          xxd \
          upx-ucl
        pip3 install lief

    - name: Extract OLLVM Toolchain
      if: ${{ inputs.use_custom_clang && inputs.obfuscation_strategy != 'binary_only' && inputs.obfuscation_strategy != 'symbolic_only' }}
      run: |
        echo "=== Extracting OLLVM Toolchain ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean any existing ollvm directory
        rm -rf /usr/local/ollvm
        mkdir -p /usr/local/ollvm
        
        # Find and extract ZIP files
        ZIP_COUNT=0
        for zip_file in "$MODULE_DIR"/clang*.zip; do
          if [ -f "$zip_file" ]; then
            ZIP_COUNT=$((ZIP_COUNT + 1))
            echo "=== Extracting $(basename "$zip_file") ==="
            unzip -q "$zip_file" -d /usr/local/ollvm/
          fi
        done
        
        if [ $ZIP_COUNT -eq 0 ]; then
          echo "⚠️ No clang*.zip files found in $MODULE_DIR/"
          echo "Available files:"
          ls -la "$MODULE_DIR"/ || echo "Directory doesn't exist"
          echo "Will use binary obfuscation only"
          echo "OLLVM_AVAILABLE=false" >> $GITHUB_ENV
        else
          # Organize binaries
          echo ""
          echo "=== Organizing Binaries ==="
          
          # Create bin directory
          mkdir -p /usr/local/ollvm/bin
          
          # Move all executables to bin/
          find /usr/local/ollvm -type f -executable -exec mv {} /usr/local/ollvm/bin/ \; 2>/dev/null || true
          
          # Make everything executable
          chmod -R +x /usr/local/ollvm/bin/ 2>/dev/null || true
          
          # Test clang
          echo ""
          echo "=== Testing OLLVM Clang ==="
          if [ -f "/usr/local/ollvm/bin/clang" ]; then
            echo "✅ OLLVM clang found"
            /usr/local/ollvm/bin/clang --version | head -3
            
            # Quick test if OLLVM works
            cat > /tmp/test_ollvm.c << 'EOF'
            int test_func(int x) { return x * 2; }
            EOF
            
            if /usr/local/ollvm/bin/clang -c /tmp/test_ollvm.c -o /tmp/test.o -mllvm -fla 2>&1; then
              echo "✅ OLLVM can compile simple code"
              echo "OLLVM_AVAILABLE=true" >> $GITHUB_ENV
            else
              echo "❌ OLLVM cannot compile even simple code"
              echo "OLLVM_AVAILABLE=false" >> $GITHUB_ENV
            fi
          else
            echo "❌ clang not found in /usr/local/ollvm/bin/"
            echo "OLLVM_AVAILABLE=false" >> $GITHUB_ENV
          fi
          
          # Add to PATH
          export PATH=/usr/local/ollvm/bin:$PATH
          echo 'export PATH=/usr/local/ollvm/bin:$PATH' >> /etc/profile.d/ollvm.sh
        fi

    - name: Build Kernel Module
      run: |
        echo "=== Building ${{ inputs.module_dir }}.ko ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean first
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
        
        # Build normally
        echo "=== Building normally ==="
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/normal_build.log
        
        # Check if build was successful
        KO_FILE=$(find "$MODULE_DIR" -name "*.ko" -type f | head -1)
        
        if [ -f "$KO_FILE" ]; then
          echo "✅ Build successful: $KO_FILE"
          cp "$KO_FILE" "$KO_FILE.original"
          echo "ORIGINAL_KO=$KO_FILE.original" >> $GITHUB_ENV
          echo "FINAL_KO=$KO_FILE" >> $GITHUB_ENV
        else
          echo "❌ Build failed: No .ko file found"
          exit 1
        fi

    - name: Apply Obfuscation
      if: ${{ inputs.use_custom_clang && success() }}
      run: |
        echo "=== Applying Obfuscation ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        ORIGINAL_KO="${{ env.ORIGINAL_KO }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        STRATEGY="${{ inputs.obfuscation_strategy }}"
        OBF_LEVEL="${{ inputs.obfuscation_level }}"
        
        if [ ! -f "$ORIGINAL_KO" ] || [ ! -f "$FINAL_KO" ]; then
          echo "❌ Kernel module files not found"
          exit 1
        fi
        
        # Apply obfuscation based on strategy and level
        case "$STRATEGY" in
          "binary_only"|"hybrid")
            echo "=== Applying Binary Obfuscation ==="
            
            # Make a backup
            cp "$FINAL_KO" "$FINAL_KO.backup"
            
            # Apply string encryption
            echo "Applying string encryption..."
            python3 << 'EOF'
import lief
import sys
import random

try:
    # Load the binary
    binary = lief.parse('$FINAL_KO')
    
    if binary is None:
        print('Failed to parse ELF')
        sys.exit(1)
    
    # Get the .rodata section (contains strings)
    rodata = None
    for section in binary.sections:
        if section.name == '.rodata':
            rodata = section
            break
    
    if rodata is not None:
        print(f'Found .rodata section: 0x{rodata.virtual_address:x} - 0x{rodata.virtual_address + rodata.size:x}')
        
        # Simple XOR encryption of printable strings
        content = bytearray(rodata.content)
        changed = 0
        
        for i in range(len(content)):
            # Simple XOR with pattern for printable ASCII
            if 32 <= content[i] <= 126:
                content[i] ^= 0xAA
                changed += 1
        
        print(f'Encrypted {changed} bytes in .rodata')
        rodata.content = list(content)
        
        # Write back
        binary.write('$FINAL_KO')
        print('String encryption complete')
    else:
        print('No .rodata section found')
        
except Exception as e:
    print(f'Error during string encryption: {e}')
    sys.exit(1)
EOF
            
            # Apply additional transformations based on level
            if [ "$OBF_LEVEL" = "medium" ] || [ "$OBF_LEVEL" = "heavy" ]; then
              echo "Applying binary transformations..."
              python3 << 'EOF'
import sys
with open('$FINAL_KO', 'rb') as f:
    data = bytearray(f.read())

# Only transform first 1KB to avoid breaking things
transform_len = min(1024, len(data))

# Simple byte swap every 4 bytes
for i in range(0, transform_len - 4, 4):
    data[i], data[i+1] = data[i+1], data[i]
    data[i+2], data[i+3] = data[i+3], data[i+2]

with open('$FINAL_KO', 'wb') as f:
    f.write(data)

print(f'Transformed {transform_len} bytes')
EOF
            fi
            
            if [ "$OBF_LEVEL" = "heavy" ]; then
              echo "Applying heavy obfuscation..."
              python3 << 'EOF'
import lief
import sys

try:
    binary = lief.parse('$FINAL_KO')
    
    if binary is None:
        print('Failed to parse ELF')
        sys.exit(1)
    
    # Find executable sections
    for section in binary.sections:
        if section.has(lief.ELF.SECTION_FLAGS.EXECINSTR):
            print(f'Found executable section: {section.name}')
            
            content = bytearray(section.content)
            
            # XOR with pattern
            pattern = [0x90, 0x90, 0x90, 0x90]  # NOP sled pattern
            for i in range(len(content)):
                content[i] ^= pattern[i % len(pattern)]
            
            section.content = list(content)
            print(f'XOR transformed {len(content)} bytes in {section.name}')
    
    # Write back
    binary.write('$FINAL_KO')
    print('XOR transformation complete')
    
except Exception as e:
    print(f'Error during XOR transformation: {e}')
EOF
            fi
            
            # Verify the file is still valid
            if file "$FINAL_KO" | grep -q "ELF"; then
              echo "✅ Binary obfuscation applied successfully"
            else
              echo "❌ Binary obfuscation corrupted the file, restoring backup"
              cp "$FINAL_KO.backup" "$FINAL_KO"
            fi
            ;;
            
          "symbolic_only"|"hybrid")
            echo "=== Applying Symbol Obfuscation ==="
            
            # Strip debug symbols
            echo "Stripping debug symbols..."
            llvm-strip -S "$FINAL_KO" 2>/dev/null || true
            strip -S "$FINAL_KO" 2>/dev/null || true
            
            # Randomize section names for heavy obfuscation
            if [ "$OBF_LEVEL" = "heavy" ]; then
              echo "Randomizing section names..."
              python3 << 'EOF'
import lief
import random
import string

def random_name(length=8):
    return '.' + ''.join(random.choice(string.ascii_lowercase) for _ in range(length))

try:
    binary = lief.parse('$FINAL_KO')
    
    if binary is None:
        print('Failed to parse ELF')
        sys.exit(1)
    
    # Randomize non-critical section names
    critical_sections = {'.text', '.data', '.bss', '.rodata', '.shstrtab', '.strtab', '.symtab'}
    
    renamed_count = 0
    for section in binary.sections:
        if section.name not in critical_sections and section.name.startswith('.'):
            old_name = section.name
            new_name = random_name()
            section.name = new_name
            renamed_count += 1
            print(f'Renamed section: {old_name} -> {new_name}')
    
    if renamed_count > 0:
        # Write back
        binary.write('$FINAL_KO')
        print(f'Section name randomization complete: {renamed_count} sections renamed')
    else:
        print('No sections to rename')
    
except Exception as e:
    print(f'Error during section randomization: {e}')
EOF
            fi
            ;;
        esac
        
        # Verify the obfuscated module
        echo "=== Verifying Obfuscated Module ==="
        
        # Basic checks
        if [ ! -f "$FINAL_KO" ]; then
          echo "❌ Obfuscated file does not exist"
          exit 1
        fi
        
        # Check if it's still ELF
        if ! file "$FINAL_KO" | grep -q "ELF"; then
          echo "❌ File is not valid ELF after obfuscation"
          exit 1
        fi
        
        # Check size
        ORIG_SIZE=$(stat -c%s "$ORIGINAL_KO")
        NEW_SIZE=$(stat -c%s "$FINAL_KO")
        
        echo "Original size: $ORIG_SIZE bytes"
        echo "New size: $NEW_SIZE bytes"
        
        # Check if file was modified
        if cmp -s "$ORIGINAL_KO" "$FINAL_KO"; then
          echo "⚠️ File was not modified by obfuscation"
        else
          echo "✅ File was modified by obfuscation"
          
          # Calculate difference
          DIFF_BYTES=$((NEW_SIZE - ORIG_SIZE))
          if [ $DIFF_BYTES -gt 0 ]; then
            echo "Size increased by: $DIFF_BYTES bytes"
          elif [ $DIFF_BYTES -lt 0 ]; then
            echo "Size decreased by: $(( -DIFF_BYTES )) bytes"
          else
            echo "Size unchanged"
          fi
        fi
        
        # Check for obvious corruption
        if readelf -h "$FINAL_KO" 2>/dev/null | grep -q "ELF"; then
          echo "✅ ELF header is valid"
        else
          echo "❌ ELF header is corrupted"
          exit 1
        fi

    - name: Create Final Artifact
      run: |
        echo "=== Creating Final Artifact ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        
        if [ ! -f "$FINAL_KO" ]; then
          echo "❌ Final kernel module not found"
          exit 1
        fi
        
        TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
        
        if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
          OBF_LEVEL="${{ inputs.obfuscation_level }}"
          STRATEGY="${{ inputs.obfuscation_strategy }}"
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-$STRATEGY-$OBF_LEVEL-$TIMESTAMP.ko"
        else
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-default-$TIMESTAMP.ko"
        fi
        
        mkdir -p /github/workspace/out
        cp "$FINAL_KO" "/github/workspace/out/$OUTPUT_NAME"
        
        # Strip debug symbols to reduce size (if not already stripped)
        echo "Stripping debug symbols..."
        llvm-strip -d "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        strip --strip-debug "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        echo "Warning: Could not strip debug symbols"
        
        echo "Final module: $OUTPUT_NAME"
        echo "Size: $(du -h "/github/workspace/out/$OUTPUT_NAME" | cut -f1)"
        echo "ARTIFACT_PATH=/github/workspace/out/$OUTPUT_NAME" >> $GITHUB_ENV

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}
        path: ${{ env.ARTIFACT_PATH }}
        retention-days: 7

    - name: Upload Build Logs
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.module_dir }}-${{ matrix.kmi }}-logs
        path: /tmp/build*.log
        retention-days: 7
      if: always()
