name: Build Kernel Module with OLLVM

on:
  workflow_dispatch:
    inputs:
      module_dir:
        description: 'Module directory to build'
        required: true
        type: choice
        options:
        - exianb-dev
        - exianb
        - ovo
        - prctl-fd
        - prctl-hook
        - offset
        - hello-world
        - wuwa
        - panic
        default: 'exianb-dev'
      obfuscation_level:
        description: 'OLLVM obfuscation level'
        required: false
        default: 'medium'
        type: choice
        options:
        - none
        - light
        - medium
        - heavy
      use_custom_clang:
        description: 'Use custom OLLVM clang from ZIP'
        required: false
        default: 'false'
        type: boolean

jobs:
  ddk-build:
    name: Build ${{ inputs.module_dir }}.ko for ${{ matrix.kmi }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        kmi:
          - android12-5.10
          - android13-5.10
          - android13-5.15
          - android14-5.15
          - android14-6.1
          - android15-6.6
          - android16-6.12

    container:
      image: ghcr.io/ylarod/ddk:${{ matrix.kmi }}

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4

    - name: Install unzip in container
      run: |
        echo "=== Installing unzip ==="
        apt-get update && apt-get install -y unzip

    - name: Extract OLLVM Toolchain
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Extracting OLLVM Toolchain ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean any existing ollvm directory
        rm -rf /usr/local/ollvm
        mkdir -p /usr/local/ollvm
        
        # Find all clang*.zip files
        echo "Looking for ZIP files in $MODULE_DIR/"
        ZIP_FILES=($(find "$MODULE_DIR" -name "clang*.zip" | sort))
        
        if [ ${#ZIP_FILES[@]} -eq 0 ]; then
          echo "❌ No clang*.zip files found!"
          exit 1
        fi
        
        echo "Found ${#ZIP_FILES[@]} ZIP file(s):"
        printf '%s\n' "${ZIP_FILES[@]}"
        
        # Extract each ZIP directly to /usr/local/ollvm
        for zip_file in "${ZIP_FILES[@]}"; do
          echo ""
          echo "=== Extracting $(basename "$zip_file") ==="
          unzip -q "$zip_file" -d /usr/local/ollvm/
        done
        
        # Make everything in bin executable
        if [ -d "/usr/local/ollvm/bin" ]; then
          chmod -R +x /usr/local/ollvm/bin/ 2>/dev/null || true
        fi
        
        # Test clang and ld.lld
        echo ""
        echo "=== Testing Toolchain ==="
        /usr/local/ollvm/bin/clang --version 2>&1 | head -2
        /usr/local/ollvm/bin/ld.lld --version 2>&1 | head -2
        
        # Add to PATH
        echo 'export PATH=/usr/local/ollvm/bin:$PATH' >> /etc/profile.d/ollvm.sh
        export PATH=/usr/local/ollvm/bin:$PATH
        
        echo "OLLVM_TOOLCHAIN_INSTALLED=true" >> $GITHUB_ENV

    - name: Debug LTO Compatibility
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Debugging LTO Compatibility ==="
        
        # Test if OLLVM works with LTO at all
        echo 'int test_func(int x) { return x * 2; }' > /tmp/lto_test.c
        
        echo ""
        echo "1. Testing normal LTO (no OLLVM):"
        /usr/local/ollvm/bin/clang -flto -c /tmp/lto_test.c -o /tmp/normal_lto.o 2>&1 && \
          echo "✅ Normal LTO compilation works" || echo "❌ Normal LTO compilation fails"
        
        echo ""
        echo "2. Testing OLLVM FLA with LTO:"
        /usr/local/ollvm/bin/clang -flto -mllvm -fla -c /tmp/lto_test.c -o /tmp/fla_lto.o 2>&1 && \
          echo "✅ FLA + LTO compilation works" || echo "❌ FLA + LTO compilation fails"
        
        echo ""
        echo "3. Testing OLLVM SUB with LTO:"
        /usr/local/ollvm/bin/clang -flto -mllvm -sub -c /tmp/lto_test.c -o /tmp/sub_lto.o 2>&1 && \
          echo "✅ SUB + LTO compilation works" || echo "❌ SUB + LTO compilation fails"
        
        echo ""
        echo "4. Testing OLLVM BCF with LTO:"
        /usr/local/ollvm/bin/clang -flto -mllvm -bcf -c /tmp/lto_test.c -o /tmp/bcf_lto.o 2>&1 && \
          echo "✅ BCF + LTO compilation works" || echo "❌ BCF + LTO compilation fails"
        
        echo ""
        echo "5. Testing combined OLLVM passes with LTO:"
        /usr/local/ollvm/bin/clang -flto -mllvm -fla -mllvm -sub -c /tmp/lto_test.c -o /tmp/combined_lto.o 2>&1 && \
          echo "✅ Combined passes + LTO compilation works" || echo "❌ Combined passes + LTO compilation fails"

    - name: Try Multiple LTO Build Approaches
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Trying Multiple LTO Approaches ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Set OLLVM flags based on level
        case "${{ inputs.obfuscation_level }}" in
          "light")
            OLLVM_FLAGS="-mllvm -fla"
            echo "OLLVM Level: light (-fla)"
            ;;
          "medium")
            OLLVM_FLAGS="-mllvm -fla -mllvm -sub"
            echo "OLLVM Level: medium (-fla -sub)"
            ;;
          "heavy")
            OLLVM_FLAGS="-mllvm -fla -mllvm -sub -mllvm -bcf"
            echo "OLLVM Level: heavy (-fla -sub -bcf)"
            ;;
          *)
            OLLVM_FLAGS=""
            echo "OLLVM Level: none"
            ;;
        esac
        
        # Clean first
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
        
        # APPROACH 1: Try ThinLTO
        echo ""
        echo "=== APPROACH 1: ThinLTO ==="
        
        set +e
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
          CC="/usr/local/ollvm/bin/clang $OLLVM_FLAGS -flto=thin" \
          LD="/usr/local/ollvm/bin/ld.lld" \
          AR="/usr/local/ollvm/bin/llvm-ar" \
          NM="/usr/local/ollvm/bin/llvm-nm" \
          OBJCOPY="/usr/local/ollvm/bin/llvm-objcopy" \
          STRIP="/usr/local/ollvm/bin/llvm-strip" \
          HOSTCC="gcc" \
          HOSTCXX="g++" \
          -j$(nproc) 2>&1 | tee /tmp/build_thinlto.log
        THINLTO_EXIT=$?
        set -e
        
        if [ $THINLTO_EXIT -eq 0 ] && [ -f "$MODULE_DIR"/*.ko ]; then
          echo "✅ ThinLTO approach successful!"
          cp /tmp/build_thinlto.log /tmp/build.log
        else
          echo "❌ ThinLTO failed"
          
          # APPROACH 2: Try with new pass manager
          echo ""
          echo "=== APPROACH 2: New Pass Manager ==="
          
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
          
          set +e
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
            CC="/usr/local/ollvm/bin/clang $OLLVM_FLAGS -flto -fexperimental-new-pass-manager" \
            LD="/usr/local/ollvm/bin/ld.lld" \
            AR="/usr/local/ollvm/bin/llvm-ar" \
            NM="/usr/local/ollvm/bin/llvm-nm" \
            OBJCOPY="/usr/local/ollvm/bin/llvm-objcopy" \
            STRIP="/usr/local/ollvm/bin/llvm-strip" \
            HOSTCC="gcc" \
            HOSTCXX="g++" \
            -j$(nproc) 2>&1 | tee /tmp/build_newpm.log
          NEWPM_EXIT=$?
          set -e
          
          if [ $NEWPM_EXIT -eq 0 ] && [ -f "$MODULE_DIR"/*.ko ]; then
            echo "✅ New Pass Manager approach successful!"
            cp /tmp/build_newpm.log /tmp/build.log
          else
            echo "❌ New Pass Manager failed"
            
            # APPROACH 3: Try without SUB pass (most problematic)
            echo ""
            echo "=== APPROACH 3: Without SUB pass ==="
            
            # Remove -sub if present (it creates bogus control flow)
            OLLVM_FLAGS_NO_SUB=$(echo "$OLLVM_FLAGS" | sed 's/-mllvm -sub//g')
            
            make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
            
            set +e
            make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
              CC="/usr/local/ollvm/bin/clang $OLLVM_FLAGS_NO_SUB -flto" \
              LD="/usr/local/ollvm/bin/ld.lld" \
              AR="/usr/local/ollvm/bin/llvm-ar" \
              NM="/usr/local/ollvm/bin/llvm-nm" \
              OBJCOPY="/usr/local/ollvm/bin/llvm-objcopy" \
              STRIP="/usr/local/ollvm/bin/llvm-strip" \
              HOSTCC="gcc" \
              HOSTCXX="g++" \
              -j$(nproc) 2>&1 | tee /tmp/build_nosub.log
            NOSUB_EXIT=$?
            set -e
            
            if [ $NOSUB_EXIT -eq 0 ] && [ -f "$MODULE_DIR"/*.ko ]; then
              echo "✅ Approach without SUB pass successful!"
              cp /tmp/build_nosub.log /tmp/build.log
            else
              echo "❌ All LTO approaches failed, falling back to no-LTO"
              
              # FINAL APPROACH: No LTO
              make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
              
              make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
                CC="/usr/local/ollvm/bin/clang $OLLVM_FLAGS -fno-lto" \
                LD="/usr/local/ollvm/bin/ld.lld" \
                AR="/usr/local/ollvm/bin/llvm-ar" \
                NM="/usr/local/ollvm/bin/llvm-nm" \
                OBJCOPY="/usr/local/ollvm/bin/llvm-objcopy" \
                STRIP="/usr/local/ollvm/bin/llvm-strip" \
                HOSTCC="gcc" \
                HOSTCXX="g++" \
                CONFIG_LTO=n \
                -j$(nproc) 2>&1 | tee /tmp/build_nolto.log
              
              cp /tmp/build_nolto.log /tmp/build.log
            fi
          fi
        fi

    - name: Build with Default Toolchain
      if: ${{ !inputs.use_custom_clang }}
      run: |
        echo "=== Building with Default Toolchain ==="
        MODULE_DIR="${{ inputs.module_dir }}"
        
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/build.log

    - name: Check Build Result
      run: |
        echo "=== Checking Build Result ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Find the .ko file
        KO_FILE=$(find "$MODULE_DIR" -name "*.ko" -type f | head -1)
        
        if [ -f "$KO_FILE" ]; then
          echo "✅ Build successful! Found: $KO_FILE"
          echo "FILE_EXISTS=true" >> $GITHUB_ENV
          echo "KO_FILE_PATH=$KO_FILE" >> $GITHUB_ENV
        else
          echo "❌ Build failed! No .ko file found."
          echo "FILE_EXISTS=false" >> $GITHUB_ENV
        fi

    # ... rest of the workflow remains the same
