name: Build Kernel Module with OLLVM

on:
  workflow_dispatch:
    inputs:
      module_dir:
        description: 'Module directory to build'
        required: true
        type: choice
        options:
        - exianb-dev
        - exianb
        - ovo
        - prctl-fd
        - prctl-hook
        - offset
        - hello-world
        - wuwa
        - panic
        default: 'exianb-dev'
      obfuscation_level:
        description: 'OLLVM obfuscation level'
        required: false
        default: 'medium'
        type: choice
        options:
        - none
        - light
        - medium
        - heavy
      use_custom_clang:
        description: 'Use custom OLLVM clang from ZIP'
        required: false
        default: 'false'
        type: boolean

jobs:
  ddk-build:
    name: Build ${{ inputs.module_dir }}.ko for ${{ matrix.kmi }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        kmi:
          - android12-5.10
          - android13-5.10
          - android13-5.15
          - android14-5.15
          - android14-6.1
          - android15-6.6
          - android16-6.12

    container:
      image: ghcr.io/ylarod/ddk:${{ matrix.kmi }}

    steps:
    - name: Checkout source code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        apt-get update && apt-get install -y \
          unzip \
          file \
          python3 \
          python3-pip \
          xxd
        pip3 install lief

    - name: Extract OLLVM Toolchain
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Extracting OLLVM Toolchain ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean any existing ollvm directory
        rm -rf /usr/local/ollvm
        mkdir -p /usr/local/ollvm
        
        # Find and extract ZIP files
        ZIP_COUNT=0
        for zip_file in "$MODULE_DIR"/clang*.zip; do
          if [ -f "$zip_file" ]; then
            ZIP_COUNT=$((ZIP_COUNT + 1))
            echo "=== Extracting $(basename "$zip_file") ==="
            unzip -q "$zip_file" -d /usr/local/ollvm/
          fi
        done
        
        if [ $ZIP_COUNT -eq 0 ]; then
          echo "❌ No clang*.zip files found in $MODULE_DIR/"
          exit 1
        fi
        
        # Organize binaries
        echo ""
        echo "=== Organizing Binaries ==="
        
        # Create bin directory
        mkdir -p /usr/local/ollvm/bin
        
        # Move all executables to bin/
        find /usr/local/ollvm -type f -executable -exec mv {} /usr/local/ollvm/bin/ \; 2>/dev/null || true
        
        # Make everything executable
        chmod -R +x /usr/local/ollvm/bin/ 2>/dev/null || true
        
        # Test clang
        echo ""
        echo "=== Testing OLLVM Clang ==="
        if [ -f "/usr/local/ollvm/bin/clang" ]; then
          echo "✅ OLLVM clang found"
          /usr/local/ollvm/bin/clang --version | head -3
        else
          echo "❌ clang not found in /usr/local/ollvm/bin/"
          exit 1
        fi
        
        # Add to PATH
        export PATH=/usr/local/ollvm/bin:$PATH
        echo 'export PATH=/usr/local/ollvm/bin:$PATH' >> /etc/profile.d/ollvm.sh

    - name: Create Obfuscation Scripts
      if: ${{ inputs.use_custom_clang }}
      run: |
        echo "=== Creating Obfuscation Scripts ==="
        
        # Create string encryption script - write line by line to avoid heredoc issues
        echo 'import lief' > /tmp/encrypt_strings.py
        echo 'import sys' >> /tmp/encrypt_strings.py
        echo 'import os' >> /tmp/encrypt_strings.py
        echo '' >> /tmp/encrypt_strings.py
        echo 'def encrypt_strings(ko_file):' >> /tmp/encrypt_strings.py
        echo '    try:' >> /tmp/encrypt_strings.py
        echo '        # Load the binary' >> /tmp/encrypt_strings.py
        echo '        binary = lief.parse(ko_file)' >> /tmp/encrypt_strings.py
        echo '        ' >> /tmp/encrypt_strings.py
        echo '        if binary is None:' >> /tmp/encrypt_strings.py
        echo '            print("Failed to parse ELF")' >> /tmp/encrypt_strings.py
        echo '            return False' >> /tmp/encrypt_strings.py
        echo '        ' >> /tmp/encrypt_strings.py
        echo '        # Get the .rodata section (contains strings)' >> /tmp/encrypt_strings.py
        echo '        rodata = None' >> /tmp/encrypt_strings.py
        echo '        for section in binary.sections:' >> /tmp/encrypt_strings.py
        echo '            if section.name == ".rodata":' >> /tmp/encrypt_strings.py
        echo '                rodata = section' >> /tmp/encrypt_strings.py
        echo '                break' >> /tmp/encrypt_strings.py
        echo '        ' >> /tmp/encrypt_strings.py
        echo '        if rodata is not None:' >> /tmp/encrypt_strings.py
        echo '            print(f"Found .rodata section: 0x{rodata.virtual_address:x} - 0x{rodata.virtual_address + rodata.size:x}")' >> /tmp/encrypt_strings.py
        echo '            ' >> /tmp/encrypt_strings.py
        echo '            # Simple XOR encryption of printable strings' >> /tmp/encrypt_strings.py
        echo '            content = bytearray(rodata.content)' >> /tmp/encrypt_strings.py
        echo '            changed = 0' >> /tmp/encrypt_strings.py
        echo '            ' >> /tmp/encrypt_strings.py
        echo '            for i in range(len(content)):' >> /tmp/encrypt_strings.py
        echo '                # Simple XOR with pattern for printable ASCII' >> /tmp/encrypt_strings.py
        echo '                if 32 <= content[i] <= 126:' >> /tmp/encrypt_strings.py
        echo '                    content[i] ^= 0xAA' >> /tmp/encrypt_strings.py
        echo '                    changed += 1' >> /tmp/encrypt_strings.py
        echo '            ' >> /tmp/encrypt_strings.py
        echo '            print(f"Encrypted {changed} bytes in .rodata")' >> /tmp/encrypt_strings.py
        echo '            rodata.content = list(content)' >> /tmp/encrypt_strings.py
        echo '            ' >> /tmp/encrypt_strings.py
        echo '            # Write back' >> /tmp/encrypt_strings.py
        echo '            binary.write(ko_file)' >> /tmp/encrypt_strings.py
        echo '            print("String encryption complete")' >> /tmp/encrypt_strings.py
        echo '            return True' >> /tmp/encrypt_strings.py
        echo '        else:' >> /tmp/encrypt_strings.py
        echo '            print("No .rodata section found")' >> /tmp/encrypt_strings.py
        echo '            return False' >> /tmp/encrypt_strings.py
        echo '            ' >> /tmp/encrypt_strings.py
        echo '    except Exception as e:' >> /tmp/encrypt_strings.py
        echo '        print(f"Error during string encryption: {e}")' >> /tmp/encrypt_strings.py
        echo '        return False' >> /tmp/encrypt_strings.py
        echo '' >> /tmp/encrypt_strings.py
        echo 'if __name__ == "__main__":' >> /tmp/encrypt_strings.py
        echo '    if len(sys.argv) != 2:' >> /tmp/encrypt_strings.py
        echo '        print("Usage: python3 encrypt_strings.py <ko_file>")' >> /tmp/encrypt_strings.py
        echo '        sys.exit(1)' >> /tmp/encrypt_strings.py
        echo '    ' >> /tmp/encrypt_strings.py
        echo '    ko_file = sys.argv[1]' >> /tmp/encrypt_strings.py
        echo '    if encrypt_strings(ko_file):' >> /tmp/encrypt_strings.py
        echo '        sys.exit(0)' >> /tmp/encrypt_strings.py
        echo '    else:' >> /tmp/encrypt_strings.py
        echo '        sys.exit(1)' >> /tmp/encrypt_strings.py
        
        # Create binary transformation script
        echo 'import sys' > /tmp/transform_binary.py
        echo '' >> /tmp/transform_binary.py
        echo 'def transform_binary(ko_file):' >> /tmp/transform_binary.py
        echo '    try:' >> /tmp/transform_binary.py
        echo '        with open(ko_file, "rb") as f:' >> /tmp/transform_binary.py
        echo '            data = bytearray(f.read())' >> /tmp/transform_binary.py
        echo '' >> /tmp/transform_binary.py
        echo '        # Only transform first 1KB to avoid breaking things' >> /tmp/transform_binary.py
        echo '        transform_len = min(1024, len(data))' >> /tmp/transform_binary.py
        echo '' >> /tmp/transform_binary.py
        echo '        # Simple byte swap every 4 bytes' >> /tmp/transform_binary.py
        echo '        for i in range(0, transform_len - 4, 4):' >> /tmp/transform_binary.py
        echo '            data[i], data[i+1] = data[i+1], data[i]' >> /tmp/transform_binary.py
        echo '            data[i+2], data[i+3] = data[i+3], data[i+2]' >> /tmp/transform_binary.py
        echo '' >> /tmp/transform_binary.py
        echo '        with open(ko_file, "wb") as f:' >> /tmp/transform_binary.py
        echo '            f.write(data)' >> /tmp/transform_binary.py
        echo '' >> /tmp/transform_binary.py
        echo '        print(f"Transformed {transform_len} bytes")' >> /tmp/transform_binary.py
        echo '        return True' >> /tmp/transform_binary.py
        echo '        ' >> /tmp/transform_binary.py
        echo '    except Exception as e:' >> /tmp/transform_binary.py
        echo '        print(f"Error during binary transformation: {e}")' >> /tmp/transform_binary.py
        echo '        return False' >> /tmp/transform_binary.py
        echo '' >> /tmp/transform_binary.py
        echo 'if __name__ == "__main__":' >> /tmp/transform_binary.py
        echo '    if len(sys.argv) != 2:' >> /tmp/transform_binary.py
        echo '        print("Usage: python3 transform_binary.py <ko_file>")' >> /tmp/transform_binary.py
        echo '        sys.exit(1)' >> /tmp/transform_binary.py
        echo '    ' >> /tmp/transform_binary.py
        echo '    ko_file = sys.argv[1]' >> /tmp/transform_binary.py
        echo '    if transform_binary(ko_file):' >> /tmp/transform_binary.py
        echo '        sys.exit(0)' >> /tmp/transform_binary.py
        echo '    else:' >> /tmp/transform_binary.py
        echo '        sys.exit(1)' >> /tmp/transform_binary.py
        
        # Create section XOR script
        echo 'import lief' > /tmp/xor_sections.py
        echo 'import sys' >> /tmp/xor_sections.py
        echo '' >> /tmp/xor_sections.py
        echo 'def xor_sections(ko_file):' >> /tmp/xor_sections.py
        echo '    try:' >> /tmp/xor_sections.py
        echo '        binary = lief.parse(ko_file)' >> /tmp/xor_sections.py
        echo '        ' >> /tmp/xor_sections.py
        echo '        if binary is None:' >> /tmp/xor_sections.py
        echo '            print("Failed to parse ELF")' >> /tmp/xor_sections.py
        echo '            return False' >> /tmp/xor_sections.py
        echo '        ' >> /tmp/xor_sections.py
        echo '        # Find executable sections' >> /tmp/xor_sections.py
        echo '        transformed = 0' >> /tmp/xor_sections.py
        echo '        for section in binary.sections:' >> /tmp/xor_sections.py
        echo '            if section.has(lief.ELF.SECTION_FLAGS.EXECINSTR):' >> /tmp/xor_sections.py
        echo '                print(f"Found executable section: {section.name}")' >> /tmp/xor_sections.py
        echo '                ' >> /tmp/xor_sections.py
        echo '                content = bytearray(section.content)' >> /tmp/xor_sections.py
        echo '                ' >> /tmp/xor_sections.py
        echo '                # XOR with pattern' >> /tmp/xor_sections.py
        echo '                pattern = [0x90, 0x90, 0x90, 0x90]  # NOP sled pattern' >> /tmp/xor_sections.py
        echo '                for i in range(len(content)):' >> /tmp/xor_sections.py
        echo '                    content[i] ^= pattern[i % len(pattern)]' >> /tmp/xor_sections.py
        echo '                ' >> /tmp/xor_sections.py
        echo '                section.content = list(content)' >> /tmp/xor_sections.py
        echo '                transformed += len(content)' >> /tmp/xor_sections.py
        echo '                print(f"XOR transformed {len(content)} bytes in {section.name}")' >> /tmp/xor_sections.py
        echo '        ' >> /tmp/xor_sections.py
        echo '        if transformed > 0:' >> /tmp/xor_sections.py
        echo '            # Write back' >> /tmp/xor_sections.py
        echo '            binary.write(ko_file)' >> /tmp/xor_sections.py
        echo '            print(f"XOR transformation complete: {transformed} total bytes")' >> /tmp/xor_sections.py
        echo '            return True' >> /tmp/xor_sections.py
        echo '        else:' >> /tmp/xor_sections.py
        echo '            print("No executable sections found")' >> /tmp/xor_sections.py
        echo '            return False' >> /tmp/xor_sections.py
        echo '            ' >> /tmp/xor_sections.py
        echo '    except Exception as e:' >> /tmp/xor_sections.py
        echo '        print(f"Error during XOR transformation: {e}")' >> /tmp/xor_sections.py
        echo '        return False' >> /tmp/xor_sections.py
        echo '' >> /tmp/xor_sections.py
        echo 'if __name__ == "__main__":' >> /tmp/xor_sections.py
        echo '    if len(sys.argv) != 2:' >> /tmp/xor_sections.py
        echo '        print("Usage: python3 xor_sections.py <ko_file>")' >> /tmp/xor_sections.py
        echo '        sys.exit(1)' >> /tmp/xor_sections.py
        echo '    ' >> /tmp/xor_sections.py
        echo '    ko_file = sys.argv[1]' >> /tmp/xor_sections.py
        echo '    if xor_sections(ko_file):' >> /tmp/xor_sections.py
        echo '        sys.exit(0)' >> /tmp/xor_sections.py
        echo '    else:' >> /tmp/xor_sections.py
        echo '        sys.exit(1)' >> /tmp/xor_sections.py
        
        echo "✅ Obfuscation scripts created"
        echo "Script contents:"
        wc -l /tmp/*.py

    - name: Build Kernel Module
      run: |
        echo "=== Building ${{ inputs.module_dir }}.ko ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        
        # Clean first
        make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
        
        # Try OLLVM build first if requested
        if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
          echo "=== Attempting OLLVM Build ==="
          
          # Set OLLVM flags based on level
          case "${{ inputs.obfuscation_level }}" in
            "light")
              OLLVM_FLAGS="-mllvm -fla"
              echo "OLLVM Level: light (flags: -fla)"
              ;;
            "medium")
              OLLVM_FLAGS="-mllvm -fla -mllvm -sub"
              echo "OLLVM Level: medium (flags: -fla -sub)"
              ;;
            "heavy")
              OLLVM_FLAGS="-mllvm -fla -mllvm -sub -mllvm -bcf"
              echo "OLLVM Level: heavy (flags: -fla -sub -bcf)"
              ;;
            *)
              OLLVM_FLAGS=""
              echo "OLLVM Level: none"
              ;;
          esac
          
          # Try with KCFLAGS
          echo "Attempting build with OLLVM flags..."
          set +e
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules \
            KCFLAGS="$OLLVM_FLAGS -fno-lto -fno-sanitize=cfi" \
            -j$(nproc) 2>&1 | tee /tmp/ollvm_build.log
          OLLVM_RESULT=$?
          set -e
          
          if [ $OLLVM_RESULT -ne 0 ]; then
            echo "❌ OLLVM build failed, falling back to normal build"
            make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" clean 2>/dev/null || true
            make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/normal_build.log
          else
            echo "✅ OLLVM build successful"
          fi
        else
          # Build normally
          echo "=== Building normally ==="
          make -C "$KERNEL_SRC" M="$PWD/$MODULE_DIR" modules -j$(nproc) 2>&1 | tee /tmp/normal_build.log
        fi
        
        # Check if build was successful
        KO_FILE=$(find "$MODULE_DIR" -name "*.ko" -type f | head -1)
        
        if [ -f "$KO_FILE" ]; then
          echo "✅ Build successful: $KO_FILE"
          cp "$KO_FILE" "$KO_FILE.original"
          echo "ORIGINAL_KO=$KO_FILE.original" >> $GITHUB_ENV
          echo "FINAL_KO=$KO_FILE" >> $GITHUB_ENV
        else
          echo "❌ Build failed: No .ko file found"
          exit 1
        fi

    - name: Apply Obfuscation
      if: ${{ inputs.use_custom_clang && success() }}
      run: |
        echo "=== Applying Obfuscation ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        ORIGINAL_KO="${{ env.ORIGINAL_KO }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        OBF_LEVEL="${{ inputs.obfuscation_level }}"
        
        if [ ! -f "$ORIGINAL_KO" ] || [ ! -f "$FINAL_KO" ]; then
          echo "❌ Kernel module files not found"
          exit 1
        fi
        
        # Make a backup
        cp "$FINAL_KO" "$FINAL_KO.backup"
        
        # Apply obfuscation based on level
        case "$OBF_LEVEL" in
          "light")
            echo "=== Light Obfuscation ==="
            echo "Applying string encryption..."
            python3 /tmp/encrypt_strings.py "$FINAL_KO"
            ;;
            
          "medium")
            echo "=== Medium Obfuscation ==="
            echo "Applying string encryption..."
            python3 /tmp/encrypt_strings.py "$FINAL_KO"
            echo "Applying binary transformations..."
            python3 /tmp/transform_binary.py "$FINAL_KO"
            ;;
            
          "heavy")
            echo "=== Heavy Obfuscation ==="
            echo "Applying string encryption..."
            python3 /tmp/encrypt_strings.py "$FINAL_KO"
            echo "Applying binary transformations..."
            python3 /tmp/transform_binary.py "$FINAL_KO"
            echo "Applying section XOR..."
            python3 /tmp/xor_sections.py "$FINAL_KO"
            ;;
            
          *)
            echo "=== No Obfuscation ==="
            ;;
        esac
        
        # Verify the file is still valid
        echo "=== Verifying Obfuscated Module ==="
        
        if [ ! -f "$FINAL_KO" ]; then
          echo "❌ Obfuscated file does not exist"
          exit 1
        fi
        
        if file "$FINAL_KO" | grep -q "ELF"; then
          echo "✅ File is still valid ELF"
        else
          echo "❌ File is not valid ELF after obfuscation, restoring backup"
          cp "$FINAL_KO.backup" "$FINAL_KO"
        fi
        
        # Check size
        ORIG_SIZE=$(stat -c%s "$ORIGINAL_KO")
        NEW_SIZE=$(stat -c%s "$FINAL_KO")
        
        echo "Original size: $ORIG_SIZE bytes"
        echo "New size: $NEW_SIZE bytes"
        
        # Check if file was modified
        if cmp -s "$ORIGINAL_KO" "$FINAL_KO"; then
          echo "⚠️ File was not modified by obfuscation"
        else
          echo "✅ File was modified by obfuscation"
        fi

    - name: Create Final Artifact
      run: |
        echo "=== Creating Final Artifact ==="
        
        MODULE_DIR="${{ inputs.module_dir }}"
        FINAL_KO="${{ env.FINAL_KO }}"
        
        if [ ! -f "$FINAL_KO" ]; then
          echo "❌ Final kernel module not found"
          exit 1
        fi
        
        TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
        
        if [ "${{ inputs.use_custom_clang }}" = "true" ]; then
          OBF_LEVEL="${{ inputs.obfuscation_level }}"
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-ollvm-$OBF_LEVEL-$TIMESTAMP.ko"
        else
          OUTPUT_NAME="$MODULE_DIR-${{ matrix.kmi }}-default-$TIMESTAMP.ko"
        fi
        
        mkdir -p /github/workspace/out
        cp "$FINAL_KO" "/github/workspace/out/$OUTPUT_NAME"
        
        # Strip debug symbols to reduce size
        echo "Stripping debug symbols..."
        llvm-strip -d "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        strip --strip-debug "/github/workspace/out/$OUTPUT_NAME" 2>/dev/null || \
        echo "Warning: Could not strip debug symbols"
        
        echo "Final module: $OUTPUT_NAME"
        echo "Size: $(du -h "/github/works
